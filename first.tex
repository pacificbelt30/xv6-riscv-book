%   terminology:
%     process: refers to execution in user space, or maybe struct proc &c
%     process memory: the lower part of the address space
%     process has one thread with two stacks (one for in kernel mode and one for
%     in user mode)
% talk a little about initial page table conditions:
%     paging not on, but virtual mostly mapped direct to physical,
%     which is what things look like when we turn paging on as well
%     since paging is turned on after we create first process.
%   mention why still have SEG_UCODE/SEG_UDATA?
%   do we ever really say what the low two bits of %cs do?
%     in particular their interaction with PTE_U
%   sidebar about why it is extern char[]

\chapter{オペレーティングシステムの構成}
\label{CH:FIRST}

オペレーティングシステムにとって重要な要求は，いろいろな活動を一度にで
きることです．たとえば，\ref{CH:UNIX}章で述べたシステムコールインター
フェースにおいて，プロセスは \lstinline{fork} を使って新しいプロセスを生む
ことができます．オペレーティングシステムは，多数のプロセス間で，コン
ピュータのリソースを\indextext{タイムシェア}（時間的に共有）しなくては
いけません．たとえば，物理的な CPU よりも多数のプロセスがあったとしても，
オペレーティングシステムはそれらの進行を保証しなくてはいけません．オペ
レーティングシステムは加えて，プロセス間の\indextext{分離}も行わなくて
はなりません．あるプロセスがバグでフェイル (fail) したとしても，別のプ
ロセスに影響があってはいけません．しかし，完全な分離は強すぎます．プロ
セス間で，意図的に相互通信したい場合もあるからです．パイプラインはその
一例です．オペレーティングシステムは，次の3つの要求を満たす必要がありま
す．すなわち，マルチプレクス (multiplexing), 分離 (isolation), および相
互通信 (interaction) です．

この章では，3 つの要求を満たすために，オペレーティングシステムがど
のように構成されているかを概説します．さまざまな実現法がありえることが
明らかになりますが，この本では\indextext{モノリシックカーネル}を中心とする主流の設
計を述べます．この章はまた，xv6 の分離の単位であるプロセスと，
xv6 の起動時における最初のプロセスの生成についても概説します．

xv6 は，マルチコアの RISC-V マイクロプロセッサで動作するので，多くの低
レベル機能（たとえばプロセスの実装）は RISC-V 固有です．RISC-V は64ビッ
ト CPU です．xv6 は特に “LP64” C, すなわち long 型とポインタ(P)型が64ビッ
トである一方，int 型は 32 ビットという C 言語で記述されています．読者に
（何らかのアーキテクチャでの）マシンレベルのプログラミングの経験が少し
あると想定し，RISC-V 固有のアイディアが出てきたらそれを紹介しま
す．RISC-V に関する便利な参考文献は “The RISC-V Reader: An Open
Architecture Atlas”~\cite{riscv} です．ユーザレベルの命令セットアーキテクチャと
権限付きアーキテクチャの公式の仕様は~\cite{riscv:user} と~\cite{riscv:priv} です．

この文章は計算を実行する要素のことを基本的に \indextext{CPU} と呼びま
す．Central Processing Unit の略です．他の文章（たとえば RISC-V の仕様
書）は，CPUのかわりに，プロセッサ，コア，および hart という用語を使うこ
ともあります．xv6 は\indextext{マルチコア}の RISC-V のハードウェアを想
定します．それはすなわち，複数の CPU がメモリを共有しながら，独立のプロ
グラムを並列で実行するということです．この文章はときどき，マルチコアと
同じ意味で\indextext{マルチプロセッサ}という用語を使います．厳密には，
マルチプロセッサとは，1つの基板に複数のプロセッサチップが載ったものを表
すこともあります．

完成品のコンピュータにおける CPU は，それを助けるためのハードウェアに囲まれており，
そのほとんどは I/O インタフェースのためにあります．xv6 は，qemu に
\texttt{-machine virt} オプションをつけてシミュレートできる
ハードウェアをサポートします．それは，RAM, ブートコードが入った ROM, 
ユーザのキーボードや画面につながったシリアル通信，およびディスクストレージを
含みます．


%% 
\section{物理的なリソースの抽象化}
%% 

オペレーティングシステムに初めて出会ったときに最初に思い浮かぶ疑問は，
なぜそんなものが必要なのか，ということかもしれません．図~\ref{fig:api} の
システムコールは，アプリケーションプログラムをリンクするライブラリとして
実現することもできます．その場合，各アプリケーションは，
そのアプリケーション専用のライブラリを使うことができます．アプリケーショ
ンは，ハードウェアリソースに直接アクセスすることができ，そのアプリケー
ションに最適な方法で使うことができます（そうすることで，高速化や，
予測可能な性能を達成できます）．実際，組込機器向けのオペレーティングシステム
やリアルタイム向けシステムには，そのような方法で構成されたものもありま
す．

ライブラリを用いたアプローチの欠点は，2 つ以上のアプリケーションが走っ
ているとき，それらのアプリケーションは行儀よくしなくてはいけないという
ことです．たとえば，各アプリケーションは，
他のアプリケーションが実行できるように
定期的に CPU を手放さなくてはなりません．各アプリケーションがお互いを信用して
おり，かつバグが無いならば，
そのような\textit{協調的}タイムシェリングはうまくいきます．しかし，アプリケーション同士は信頼しあっ
ておらず，かつバグがあるのがより一般的な状況です．そのため，協調的な方
法よりも，より強い分離が欲しいときがあります．

強い分離を実現するよい方法は，アプリケーションに，繊細なハードウェアリソース
を直接触らせないことです．そのかわり，リソースをサービスとして
抽象化するのです．たとえば，アプリケーションが生のディスクのセクタを直
接読み書きするかわりに，\lstinline{open}, \lstinline{read}, \lstinline{write},
および \lstinline{close}システムコールを介してファイルシステムにアクセスさ
せるのです．そのようにすることで，アプリケーションはパスや名前でアクセ
スができて便利になるとともに，オペレーティングシステムは（そのインタ
フェースの実装者として）ディスクを管理することができます．

同様に，Unix は複数のプロセスに対してハードウェアの CPU を透過的に切り
替えます．レジスタ状態を必要に応じて退避することで，アプリケー
ションがタイムシェアリングであることを気にしなくてよいようにします．
この透過性により，たとえ無限ループに陥るアプリケーションがいたとしても，
オペレーティングシステムは CPU を共有することができます．

Unix のプロセスが，物理メモリと直接やり取りするかわり
に，\lstinline{exec} を使ってメモリイメージを構築するのは別の例です．そうすることで，
オペレーティングシステムはメモリのどこにそのプロセスを置くか決めること
ができるようになります．もしメモリが足りなかったら，オペレーティングシ
ステムはプロセスのデータの一部をディスクに保存することもできま
す．\lstinline{exec} により，実行可能なプログラムイメージを，ファ
イルシステムに保存するという利便性もあります．

Unix プロセス間の相互通信の多くは，ファイルディスクリプタを経由して行い
ます．ファイルディスクリプタは，抽象化によって詳細（たとえばパイ
プの中のデータやファイルはどこに保存されているか，など）を気にしなくて
よくなるだけでなく，相互通信を単純化する方法も規定します．たとえば，
パイプライン中のあるアプリケーションがフェイルした場合，カーネルはファイル
終端シグナルをパイプラインの次のプロセスに送ることができます．

ここで見たように，図~\ref{fig:api} のシステムコールは緻密に設計されてお
り，プログラマの便利さだけでなく，強い分離を行う機会を提供します．Unix
インタフェースはリソースを抽象化する唯一の方法ではありませんが，とても
良いものであると知られています．

%% 
\section{ユーザモード，スーパーバイザモード，およびシステムコール}
%% 

強い分離をするには，アプリケーションとオペレーティングシステムの間に明
確な境界線が必要です．もしあるアプリケーションがフェイルしても，オペ
レーティングシステムや別のアプリケーションにはフェイルが伝搬しないで欲しい
です．オペレーティングシステムはフェイルしたアプリケーションを
片づけ，他のアプリケーションを実行させ続けなくてはいけません．そのよう
な強い分離を実現するには，あるアプリケーションがオペレーティングシステ
ムのデータ構造や命令列を変更できなくする（あるいは見ることすらできなく
する）とともに，別のアプリケーションのメモリにアクセスできなくする必要
があります．

多くの CPU には，強い分離を行うためのハードウェア的な支援機能があります．
たとえば，RISC-V は CPU が命令列を実行するのに3つのモードがあります．
\indextext{マシンモード}，\indextext{スーパーバイザモード}，および\indextext{ユーザモード}です．マ
シンモードで実行する命令列は無制限の権限を持ちます．起動直後の CPU はマ
シンモードです．マシンモードは，ほとんどの場合，コンピュータのコンフィ
ギュレーションで使います．xv6 がマシンモードで実行するのはわずか数行で，そのあとは
スーパーバイザモードに切り替わります．

スーパーバイザモードにおいて，CPU は\indextext{特権命令}を実行すること
ができます．特権命令を用いると，たとえば，割込の有効化・無効化や，ペー
ジテーブルのアドレスを指定するレジスタの読み書きなどができます．もしユー
ザモードのアプリケーションが特権命令を実行しようとすると，CPU はその命
令を実行せず，かわりに，スーパーバイザモードに切り替わります．そして，
するべきでないことをしようとしたアプリケーションを強制終了しま
す．\ref{CH:UNIX} 章の図~\ref{fig:os} はそのような構成を示しています．
アプリケーションはユーザモードの命令（たとえば足し算など）のみを実行す
ることができ，それを「\indextext{ユーザ空間}で実行している」と言います．
それに対し，スーパーバイザモードでは特権命令も実行することができ，
「\indextext{カーネル空間}で実行している」と言います．
\indextext{カーネル}とは，カーネル空有で実行する（あるいはスーパーバイザモードで実行す
る）ソフトウェアのことです．

あるアプリケーションが，カーネルの関数（たとえば xv6 におけ
る\lstinline{read} システムコール）を呼びたいと思ったら，カーネルに切り替
えなくてはいけません．CPU が提供する特殊な命令を実行すると，ユーザモー
ドからスーパーバイザモードが切り替わった上で，カーネルが指定するエント
リポイントに飛びます (RISC-V では \indexcode{ecall} 命令を使います)．CPU
がスーパーバイザモードに切り替わると，カーネルはシステムコールの引数を
検証し，そのアプリケーションが実行して良い要求なのか判断し，実行するか
拒否します．スーパーバイザへの切り替えにおけるエント
リポイントをカーネルが支配するのは重要です．もしアプリケーションがカー
ネルのエントリポイントを選べたとしたら，悪意を持ったアプリケーションは，
たとえば，引数の検証を回避できる場所を選ぶことができてしまいます．


%% 
\section{カーネルの構成}
%% 

オペレーティングシステムのどの部分をスーパーバイザモードで実行するかが，
設計上の重要な問いです．ひとつの方法は，オペレーティングシステム全体を
カーネルに入れてしまい，システムコールの実装全体をスーパーバイザモードで
実行させることです．この構成を\indextext{モノリシックカーネル}と呼びます．

この構成では，オペレーティングシステム全体が無制限のハードウェア特
権を持って実行されます．そうすると，ハードウェア特権が必要な場所とそ
うでない場所を判断しなくてよくなるので，OS の設計者にとって楽で
す．さらに，オペレーティングシステムの異なる部分同士が簡単に協調できる
ようになります．たとえば，ファイルシステムと仮想メモリシステムの間に，
共有のバッファキャッシュを用意する場合などです．

モノリシックカーネルの欠点は，オペレーティングシステムの異なる部分同士
のインタフェースが複雑になりがちなことです（本書のあとの方で詳しく見ま
す）．そうすると，オペレーティングシステムの開発者が間違いを犯しやすくなり
ます．モノリシックカーネルにおいて間違いは致命的です．スー
パーバイザモードでは，たとえ小さな間違いであってもカーネルをフェイルさせうる
からです．カーネルがフェイルするとコンピュータは止まってしまい，
アプリケーションも当然フェイルします．復帰するには，コンピュータを再起動しなくては
いけません．

カーネルにおける間違いを減らすために，スーパーバイザモードで実行するコー
ドを厳選し，オペレーティングシステムの大部分をユーザモードで走らせるこ
ともできます．そのようなカーネルの構成法を\indextext{マイクロカーネル}と呼びます．

\begin{figure}[t]
\center
\includegraphics[scale=0.5]{fig/mkernel.pdf}
\caption{マイクロカーネルとファイルサーバ}
\label{fig:mkernel}
\end{figure}

図~\ref{fig:mkernel} にマイクロカーネルを図示します．図において，ファイルシステ
ムはユーザレベルのプロセスとして走ります．プロセスとして走る OS のサー
ビスをサーバと呼びます．アプリケーションがファイルサーバと相互通信で
きるように，カーネルはプロセス間通信のメカニズムを提供することで，あるユーザ
モードプロセスから別のユーザモードプロセスにメッセージを送れるようにし
ます．たとえば，シェルのようなアプリケーションがファイルの読み書きをし
たいと思ったら，そのアプリケーションはファイルサーバにメッセージを送り，
その応答を待ちます．

マイクロカーネルにおけるカーネルのインタフェースは，アプリケーション
を開始する，メッセージを送る，デバイスのハードウェアにアクセスするなどのご
く少ない低レベル関数からなります．そのような構成を取ると，オペレーティ
ングシステムの大部分はユーザレベルのサーバとなるため，カーネルを比較的
単純にすることができます．

xv6 は，多くの Unix オペレーティングシステムと同様に，モノリシックカー
ネルとして実装します．xv6 のカーネルインタフェースはオペ
レーティングシステムのインタフェースと同一であり，カーネルがオペレーティ
ングシステム全体を実装します．xv6 はそこまで多くのサービスは提供しない
ため，ある種のマイクロカーネルよりも小さいのですが，コンセプト上，
xv6 はモノリシックです．


\section{Code: xv6 の構成}

\begin{figure}[t]
\center
{\footnotesize
  \begin{tabular}{l|l} 
\textbf{ファイル名} & \textbf{説明} \\ \midrule
\texttt{bio.c}         & ファイルシステムのためのディスクブロックキャッシュ．\\
\texttt{console.c}     & ユーザのキーボードと画面への接続．\\
\texttt{entry.S}       & 起動時の一番最初の命令列． \\
\texttt{exec.c}        & \texttt{exec()} システムコール．\\
\texttt{file.c}        & ファイルディスクリプタのサポート．\\
\texttt{fs.c}          & ファイルシステム． \\
\texttt{kalloc.c}      & 物理ページのアロケータ． \\
\texttt{kernelvec.S}   & カーネルおよびタイマ割込からのトラップの処理． \\
\texttt{log.c}         & ファイルシステムのロギングとクラッシュリカバリ．\\
\texttt{main.c}        & ブート時の他モジュールの初期化を制御． \\
\texttt{pipe.c}        & パイプ． \\
\texttt{plic.c}        & RISC-V の割込コントローラ． \\
\texttt{printf.c}      & 画面へのフォーマット付き出力． \\
\texttt{proc.c}        & プロセスとそのスケジューリング． \\
\texttt{sleeplock.c}   & CPU を手放すロック．\\
\texttt{spinlock.c}    & CPU を手放さないロック．\\
\texttt{start.c}       & 初期のマシンモードでのブートコード． \\
\texttt{string.c}      & C 文字列とバイト配列のためのライブラリ． \\
\texttt{swtch.S}       & スレッド切り替え． \\
\texttt{syscall.c}     & 実際に処理をする関数にシステムコールをディスパッチする． \\
\texttt{sysfile.c}     & ファイル関連のシステムコール． \\
\texttt{sysproc.c}     & プロセス関連のシステムコール． \\
\texttt{trampoline.S}  & ユーザとカーネルを切り替えるためのアセンブリコード． \\
\texttt{trap.c}        & トラップと割込を処理してリターンするための C コード． \\
\texttt{uart.c}        & シリアルポートコンソールのデバイスドライバ． \\
\texttt{virtio\_disk.c} & ディスクのデバイスドライバ． \\
\texttt{vm.c}          & ページテーブルとアドレス空間の管理．
  \end{tabular}
}
\caption{Xv6 kernel source files.}
\label{fig:source}
\end{figure}

xv6 のカーネルのソースは \texttt{kernel/} サブディレクトリに入っていま
す．ソースは，荒くモジュール化され，ファイル分けされています．
図~\ref{fig:source} はファイルの一覧です．それぞれのモジュールとのインタフェースは，
\lstinline{defs.h} \fileref{kernel/defs.h} で定義されています.

%% 
\section{プロセスの概要}
%% 

xv6 における分離の単位は（他の Unix オペレーティングシステムと同様
に）\indextext{プロセス}です．プロセスによる抽象化を行うことで，あるプ
ロセスが別のプロセスのメモリ, CPU, およびファイルディスクリプタなどを壊
したり覗いたりできないようになります．同様に，プロセスがカーネルを破壊
できないようにすることで，分離メカニズムを迂回できないようにします．カー
ネルは，プロセスの抽象化を注意深く実装しなくてはいけません．さもなくば，
バグっていたり悪意を持ったアプリケーションが，カーネルやハードウェアを
だまして何か悪いことを引き起こすからです（例: 分離の迂回）．カーネルが
プロセスを実装するために用いるメカニズムには，ユーザモード・スーパーバ
イザモードのフラグ，アドレス空間，スレッドのタイムスライスなどがありま
す．

分離の強制力を高めるために，プロセスを抽象化することで，あるプ
ログラムは，あたかもマシンを専有しているかのように見せます．
プロセスはプログラムに対し，他のプロセスが読み書きすることができない，
そのプロセス固有に見えるメモリシステム（あるいは\indextext{アドレス空間}）を提供し
ます．加えて，そのプログラムの命令列を専属で実行するかのように見える
CPU を提供します．

xv6 はページテーブル（ハードウェア的に実装されるもの）を用いて，各プロ
セスに固有のアドレス空間を与えます．RISC-V のページテーブルは，
\indextext{仮想アドレス}（RISC-V 命令が扱うアドレス）を，
\indextext{物理アドレス}（CPU がメインメモリ
に送るアドレス）に翻訳（あるいはマップ）します．

\begin{figure}[t]
\centering
\includegraphics[scale=0.5]{fig/as.pdf}
\caption{ユーザプロセスの仮想アドレス空間のレイアウト}
\label{fig:as}
\end{figure}

ページテーブルはそのプロセスのアドレス空間を決めるもので，xv6 は，プロ
セスごとに別のページテーブルを用意します．図~\ref{fig:as} に示すように，アドレス
空間には，そのプロセスの\indextext{ユーザメモリ}が，仮想アドレス0番から入っています．
最初に命令列，続いてグローバル変数，次にスタック，そして最後にヒープ領
域（malloc のためのもので，プロセスが必要に応じて増やせるもの）がありま
す．xv6 は，仮想アドレス 39 ビットのRISC-V で動きますが，そのうち 38 ビッ
トしか使いません．よって，最大長は $2^{38}-1$ = \texttt{0x3fffffffff}
で，これは \lstinline{MAXVA}~\lineref{kernel/riscv.h:/MAXVA/} です．\ref{CH:TRAP}~章で詳しく見るよう
に，アドレス空間の先頭には\indextext{トランポリン}のための 1 ページと，プロセ
スの\indextext{トラップフレーム}がカーネルに切り替わるための1ページがあります．

xv6 カーネルは，プロセスごとにさまざまな状態を保持しており，それら
は\indexcode{proc} 構造体~\lineref{kernel/proc.h:/^struct.proc/} に収まっています．プロセスに
とってもっとも重要なカーネルの状態は，ページテーブル，カーネルスタック，お
よび実行状態です．以降は，\lstinline{proc}~構造体の各要素を示すために\indexcode{p->xxx} と
いう記法を使います．たとえば，上述したトラップフレームは \indexcode{p->tf} です．

各プロセスは，そのプロセスの命令列を実行する実行スレッド（あるいは単純
に\indextext{スレッド}）を持ちます．スレッドは中断して，あとで再開できます．プ
ロセスを透過的に切り替えるときには，カーネルは現在走っているスレッドを
中断し，別のプロセスのスレッドを再開します．スレッド内の状態（ローカル
変数，関数コールにおけるリターンアドレス）は，そのスレッド固有のスタックに
記憶されます．プロセスは 2 つのスタックを持ちます．1 つはユーザスタッ
ク，もう 1 つはカーネルスタック(\indexcode{p->kstack}) です．プロセスがユー
ザの命令列を実行しているときはユーザスタックのみが利用され，カーネルス
タックは空です．（システムコールや割込により）プロセスがカーネルに入る
と，カーネルのコードはそのプロセスのカーネルスタックを用いて実行を行います．
あるプロセスがカーネルに入っているとき，ユーザスタックは記憶されたデータを
保持し続けますが，積極的には利用はされません．プロセスのスレッドは，
ユーザスタックとカーネルスタックを行ったり来たりします．カーネルスタックは分離
されているため（そしてユーザコードからは保護されているため），あるプロセスが
自身のスタックを壊してしまったとしても，カーネルは実行を継続できます．

プロセスは，システムコールを呼ぶために RISC-V の \indexcode{ecall} 命令を
実行します．この命令は，ハードウェアの特権レベルを上げ，プログラムカウ
ンタをカーネルが決めたエントリポイントに移します．システムコールが完了
すると，カーネルはスタックをユーザスタックに切り替え，それか
ら \indexcode{sret} 命令を呼んでユーザ空間にリターンします．\texttt{sret} 命令は，
ハードウェア特権レベルを下げ，システムコール命令の直後の命令から実行を再
開します．プロセスのスレッドは，I/O を待つために，カーネルで「ブロック」す
ることがあります．その場合，I/O が完了すると実行を再開します．

\indexcode{p->state} は次のうちいずれかを表します: プロセスがアロケート済みである, 
実行待ちである，実行中である，I/O を待っている，終了中である．

\indexcode{p->pagetable} は，そのプロセスのページテーブルです．ペー
ジテーブルは，RISC-V が指定するフォーマットで表現されます．
あるプロセスをユーザ空間で実行し始めるとき，xv6 そのプロセス
の \lstinline{p->pagetable} を使うようにページングハードウェアに指示します．
プロセスのページテーブルは，そのプロセスのためにアロケートさ
れた物理ページのアドレスの一覧にもなっています．

%% 
\section{Code: xv6 の起動と最初のプロセス}
%% 
xv6 をより具体化するために，カーネルがどのように開始し，そしてどうやって最初のプロセスを
起動するか概説します．続く章では，ここで出てくるメカニズムをより詳しく
説明します．

RISC-V コンピュータの電源がオンになると，CPU は自身を初期化して，
リードオンリーメモリに入ったブートローダを実行します．ブートローダは
xv6 カーネルをメモリにロードします．そのあと，マシンモード状態の
CPU は \indexcode{_entry} \lineref{kernel/entry.S:/^.entry:/} から
実行を始めます．xv6 が開始したとき，RISC-V のページングハードウェアはまだ無効であり，
仮想アドレスと物理アドレスは直接マップされています．


ローダは，xv6 カーネルを物理アドレス \texttt{0x80000000} にロードします．
\texttt{0x0} ではなく \texttt{0x80000000} から始めるのは，
\texttt{0x0}〜\texttt{0x80000000} のアドレス範囲には I/O デバイスが
割りあたっているからです．

\lstinline{_entry} にある命令列は，スタックを設定することで，xv6 が C コードを実
行できるようにします．xv6 は，最初のスタックである \lstinline{stack0}
を \lstinline{start.c} で宣言していま
す \lineref{kernel/start.c:/stack0/}．\lstinline{_entry} のコードは，スタックポインタレ
ジスタ \lstinline{sp} に，スタックアドレス \lstinline{stack0+4096} を代入しま
す．RISC-V のスタックは下向きに育つので，このアドレスがスタックの先頭となり
ます．スタックが準備できたら，\lstinline{_entry} は\lstinline{start} の C コードに入りま
す \lineref{kernel/start.c:/^start/}.

その関数（たち）はマシンモードでしか許されていない各種コンフィギュレーションを行い，
そのあとスーパーバイザモードに切り替えます．スーパーバイザモードに入るために，
RISC-V には \lstinline{mret} 命令があります．この命令は，
ほとんどの場合，どこかでスーパーバイザモードからマシンモードへの呼び出しが
行われたあと，元の場所にリターンするために使います．しかし，\lstinline{start} は
そのような呼び出しからリターンするわけではありませんので，あたかもそうであったかの
ように準備をします．そのために次を行います: 
(i) 前の特権がスーパーバイザであることを \lstinline{mstatus} レジスタにセッ
トする，(ii) \lstinline{mepc} レジスタに main 関数のアドレスを書き込むこと
で，返り先を main に指定する, (iii) ページテーブル用レジス
タ \lstinline{satp} に 0 を書き込むことで，仮想アドレスへの変換を無効化す
る，(iv) 全ての割込と例外をスーパーバイザモードに移譲する．

スーパーバイザモードにジャンプする前に，もう1つやらなくてはいけないこと
があります．タイマ割込を行うように，クロックチップに設定を書
き込むことです．以上の面倒を見終わったら，\lstinline{starn} は \lstinline{mret}
を呼ぶことでスーパーバイザモードへ「リターン」します．それにより，プログラムカウンタは
\lstinline{main} \lineref{kernel/main.c:/^main/} に移ります．

\lstinline{main} \lineref{kernel/main.c:/^main/} は，さまざまなデバイスとサブシステムの
初期化を追えると，\lstinline{userinit} を呼んで最初のプロセスを生成しま
す \lineref{kernel/proc.c:/^userinit/}．最初のプロセスは小さなプログラムであ
る\lstinline{initcode.S} \lineref{user/initcode.S:1} を実行します．それ
は，\indexcode{exec} システムコールを呼んで再びカーネルに入ります．1章で見
たように，\lstinline{exec} はそのプロセスのメモリやレジスタを，新しいプロ
グラム（今回は \indexcode{/init}）に取り替えます．カーネル
が \lstinline{exec} を実行し終えると，そのプロセスはユーザ空間にリターンし
て \lstinline{/init} の実行が始まります．\lstinline{init} \lineref{user/init.c:/^main/} は，必要
に応じてコンソール用の新しいデバイスファイルを生成し，それをファイルディ
スクリプタ0, 1, および 2番として開きます．そのあと，コンソール用シェルを
起動し，孤立したゾンビプロセスの面倒を見るためのループに入りま
す．こうしてシステムは起動しました．

%% 
\section{世の中のオペレーティングシステム}
%% 

現実の世界には，モノリシックカーネルとマイクロカーネルの両方があります．
多くの Unix カーネルはモノリシックです．たとえば，Linux はモノリシック
カーネルです．ただし，一部の機能 (たとえばウィンドウシステム)はユー
ザレベルサーバとして動きます．L4, Minix, および QNX のようなカーネルは
サーバを用いるマイクロカーネルの構成を持ち，組込用途で広く使われていま
す．

多くのオペレーティングシステムが，プロセスというコンセプトを採用してお
り，それは xv6 のプロセスと似たものです．ただし，現代的なオペレーティン
グシステムは，1つのプロセス内に複数のスレッドを持つことをサポートします．
そうすることで，1つのプロセスが複数の CPU を使うことができるようになり
ます．1つのプロセス内で複数のスレッドを動かせるようにするには，xv6 には
ない多くのしかけ（たとえば，Linux は \lstinline{clone} とい
う \lstinline{fork} の派生版を使います）を用いることで，プロセス内のスレッ
ドが何を共有するか制御する必要があります．

%% 
\section{練習問題}
%%

\begin{enumerate}

\item gdb を使うと，カーネルからユーザへの，一番最初の切り替えを観察す
  ることができます．\texttt{make qemu-gdb} を実行してください．別のウィ
  ンドウにおいて，同じディレクトリで gdb を実行してください．gdb のコマ
  ンド \texttt{break *0x3ffffff07e} を実行することで，ユーザ空間にジャ
  ンプする \texttt{sret} 命令にブレークポイントを設定してください．gdb
  で \texttt{continue} コマンドを入力すると，gdb はそのブレークポイント
  において，\texttt{sret} を実行する直前で停止します．\texttt{stepi} を
  入力すると，アドレス \texttt{0x4} 番に実行が移ることが，gdb で確認で
  きます．このアドレスはユーザ空間における，\texttt{initcode.S} の先頭を
  指しています．

% break *0x3ffffff000
% disas 0x3ffffff000,+8
% set disassemble-next-line auto
% x/i $pc
% break *0x3ffffff07e
% print/x $sepc
% print/x $pc

\end{enumerate}
