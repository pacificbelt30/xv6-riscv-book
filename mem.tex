% talk a little about initial page table conditions:
%     paging not on, but virtual mostly mapped direct to physical,
%     which is what things look like when we turn paging on as well
%     since paging is turned on after we create first process.
%   mention why still have SEG_UCODE/SEG_UDATA?
%   do we ever really say what the low two bits of %cs do?
%     in particular their interaction with PTE_U
%   sidebar about why it is extern char[]
\chapter{ページテーブル}
\label{CH:MEM}

ページテーブルは，オペレーティングシステムが各プロセスに対し，そのプロセス
固有のアドレス空間とメモリを提供するためのメカニズムです．ページテーブルは，メ
モリアドレスの意味と，物理メモリのどこにアクセスできるかを決めま
す．xv6 はページテーブルを用いることで，異なるプロセス間のアドレス空間を分離する
とともに，１つしかない物理メモリをマルチプレクスします．ペー
ジテーブルが提供する間接的なアクセスは，次のようなトリックを実現
するのにも役立ちます．同一のメモリ（トランポリンページ）を複数のアドレス
空間にマップするトリックや，未割り当てページを作ることでカーネルスタックとユー
ザスタックの間をガードするトリックです．本章の残りは，RISC-V が提供する
ページテーブルと，それを xv6 がどのように使うかを説明します．

%% 
\section{ページングハードウェア}
%% 
RISC-V の命令列は（ユーザもカーネルもどちらも）仮想アドレスを使います．それに対して
マシンの RAM, すなわち物理メモリは物理アドレスを使います．RISC-V の
ページテーブル用ハードウェアは，仮想アドレスを物理アドレスにマップする
ことで，それら2種類のアドレスを結びつけます．


\begin{figure}[t]
\center
\includegraphics[scale=0.5]{fig/riscv_address.pdf}
\caption{RISC-V の仮想アドレスと物理アドレス}
\label{fig:riscv_address}
\end{figure}

xv6 が動作するのは Sv39 RISC-V, すなわち 39 ビットの仮想アドレスを持つ
ものです（図~\ref{fig:riscv_address} を見てください）．64ビットの仮想アドレスのう
ち，上位 25 ビットは使用しません．Sv39 のコンフィギュレーションにおい
て，RISC-V のページテーブルは，論理的には，$2^{27}$ (134,217,728) 個の
\indextext{ページテーブルエントリ} (PTE: Page Table Entries) からなる配列です．
各 PTE は，44 ビットの物理ページ番号 (PPN: Physical Page Number) と，各
種フラグを含みます．ページングハードウェアは，39 ビット中の上位 27 ビッ
トをインデックスとして用いてページテーブルから PTE を探し，PPN の44 ビッ
トと，仮想アドレス下位12ビットを連結して 56 ビットの物理アドレスを作り
ます．すなわち，ページテーブルは，4096 ($2^{12}$) バイトに整列した塊を
粒度として，仮想・物理アドレスの変換を制御することができます．そのよう
な塊を\indextext{ページ}と呼びます．

\begin{figure}[t]
\center
\includegraphics[scale=0.5]{fig/riscv_pagetable.pdf}
\caption{RISC-V のページテーブルのハードウェア}
\label{fig:riscv_pagetable}
\end{figure}

Sv39 RISC-V において，仮想アドレスの上位25ビットは，アドレス変換には利
用しません．将来的に，RISC-V はそれらのビットを，さらなるアドレス変換の
階層のために利用するかもしれません．同様に，物理アドレスも増やす余地があります．
Sv39 では 56 ビットですが，64 ビットまで増やすことができます．

図~\ref{fig:riscv_pagetable} に示すように，実際のアドレス変換は 3 ステップからなり
ます．ページテーブルは 3 階層のツリーとして，物理メモリに保存されていま
す．ツリーのルートは，4096 バイトのページテーブル用ページ (page-table
page)です．このページは 512 個の PTE を含み，各エントリは次の階層のペー
ジテーブル用ページの物理アドレスを指します．ツリーの最後の階層に至るま
で，どのページも 512 個の PTE を含みます．ページテーブルのハードウェア
は，ルートにあるページテーブル用ページから PTE を選択するインデックスと
して，27 ビットのうち最上位 9 ビットを用います．その次の階層では中間
の 9 ビットを，最後の階層では最後の 9 ビットをそれぞれ用います．

もし，アドレス変換に必要な 3 つ PTE のうち 1 つでも足りなければ，ページ
ング用ハードウェアはフォールト (fault) を発生させます．一般的な用途にお
いて，仮想アドレスの大半は未割り当てです．上記のような 3 階層の構造を用
いることで，未割り当ての範囲に対応するページテーブル用ページ全体を
省略し，メモリを節約できます．

各 PTE は，フラグビットを含んでおり，対応する仮想アドレスを使用してよい
かどうかをページテーブル用ハードウェアに伝えるために利用されま
す．\indexcode{PTE_V} は，PTE が存在するかどうかを示します．もしフラグが
セットされていなければ，そのページへの参照はフォールトを生じます（すな
わち許可されません）．\indexcode{PTE_R} は，命令列が，そのページを読んで
よいかどうかを指定します．また，\indexcode{PTE_W} は，命令列が，そのペー
ジに書き込んでよいかどうかを指定します．\indexcode{PTE_X} は，そのページ
の中身を命令として解釈し，実行して良いかどうかを指定しま
す．\indexcode{PTE_U} は，ユーザモードで実行する命令列が，そのページアク
セスできるかどうかを指定します．もし \indexcode{PTE_U} がセットされていな
ければ，その PTE はスーパーバイザモードでのみ使うことができます．
図~\ref{fig:riscv_pagetable} に，以上がどのように動くか示します．各フラグと，ページ
ング用ハードウェアに関連した構造体は \fileref{kernel/riscv.h} で定義されていま
す．

あるページテーブルを使うようにハードウェアに指示するためには，ルートと
なるページテーブル用ページの物理アドレスを，\texttt{satp} レジスタに書
き込みます．各 CPU は，固有の\texttt{satp}\index{satp@\lstinline{satp}} レジスタを持ちます．CPU は，
続く命令列が生成するアドレスを，その CPU 固有の \texttt{satp} が指すペー
ジテーブルを用いてアドレス変換します．各 CPU が固有の \texttt{satp} を
持つので，各 CPU はそれぞれ別のプロセスを実行できます．
プロセスは，ページテーブルが規定する固有のアドレス空間を持っています．

用語について注意をしておきます．物理メモリとは，DRAM 内部の記憶セルを意
味します．物理メモリ内のバイトはアドレスを持ち，それを物理アドレスと呼
びます．命令は仮想アドレスしか扱いません．仮想アドレスはページング用ハー
ドウェアによって物理アドレスに変換され，その上で DRAM に送られて読み書
きに利用されます．仮想アドレスと物理アドレスの間を取り持つ，カーネルが
提供する抽象化のための機能の集まりのことを仮想メモリと呼びます．


\begin{figure}[h]
\centering
 \includegraphics[scale=0.65]{fig/xv6_layout.pdf}
\caption{（左）xv6 のカーネルのアドレス空間．\texttt{RWX} は PTE の読
み書き実行 (Read, Write, Execute) のパーミッションを示す．（
右）xv6 が想定する RISC-V の物理アドレス空間．}
\label{fig:xv6_layout}
\end{figure}

%% 
\section{カーネルのアドレス空間}
%% 
カーネルは，自身のためのページテーブルを持ちます．プロセスがカーネ
ルに入ると，xv6 はカーネル用のページテーブルに切り替えます．そのあと，カー
ネルがユーザ空間へ返るときは，xv6 はユーザプロセス用のページテーブルに
切り替え直します．カーネルのメモリはプライベートです．

図~\ref{fig:xv6_layout} はカーネルのアドレス空間のレイアウトと，仮想アドレスから物理アド
レスへのマッピングを図示しています．あるファイル \fileref{kernel/memlayout.h}
に，xv6 のカーネルのメモリレイアウトを規定する定数が宣言されています．

QEMU は，I/O デバイス（たとえばディスクインタフェース）を含むコンピュー
タをシミュレートします．QEMU は，デバイスのインタフェースを，
\indextext{メモリマップ}された制御レジスタとしてソフトウェアに見せます．それらは，物理メモリ
の \texttt{0x80000000} 未満にマップされます．カーネルはメモリ
領域を読み書きすることで，それらのデバイスとやりとりできます．\ref{CH:TRAP}~章で
は，xv6 がどのようにデバイスとやりとりするかを説明します．

カーネルは，仮想空間の大部分を，そのままマップします．すなわち，カーネ
ルのアドレス空間のほとんどは，ダイレクトマッピングされています．たとえ
ば，カーネル自身は，仮想アドレスでも物理アドレスでも \lstinline{KERNBASE}
にあります．カーネルは通常の（仮想アドレスを用いた）ページの読み書きと，
（物理アドレスを用いた）PTE 操作の両方を行う必要がありますが，ダイレ
クトマッピングを用いることでそのコードを簡単にすることができます．
ただし，ダイレクトマッピングされていない仮想アドレスもいくつかあります．


\begin{itemize}
  
\item トランポリンページ．仮想アドレス空間の先頭にマップされます．
  どのユーザのページテーブルでも同じマッピングを持ちます．\ref{CH:TRAP}~章において
  このトランポリンページの役割を説明しますが，この部分はページテーブルの
  面白い利用例になっています．（トランポリンのコードを含む）物理ページは，
  カーネルの仮想アドレス空間に 2 つマップされます．1 つは仮想アドレス空間の
  先頭であり，もう 1 つはカーネルの text 領域です．

\item カーネルのスタックのページ．各プロセスは，固有のカーネルスタック
  を持ち，高位アドレス側にマップします．そうすることで，下位側に未割り当て
  の\indextext{ガードページ}を置くことができます．ガードページの PTE は無効で
  す（すなわち \lstinline{PTE_V} はセットされていません）．そうすることに
  より，カーネルがカーネルのスタックをオーバーフローさせてしまった場合，
  高い確率でフォールトを起こし，カーネルがパニックを起こして止まることが
  できます．もしガードページがなければ，オーバーフローはカーネルのメモ
  リを上書きし，不正な処理をしてしまう可能性があります．
  それならば，パニックでクラッシュする方がマシです．

\end{itemize}

カーネルは上位メモリへのマッピングを介してスタックを利用しますが，ダイ
レクトマッピングされたアドレスを用いてもアクセスできます．ダイレクトマッ
ピングだけを用意し，スタックをダイレクトマッピングされたアドレスで使う
という設計もありえました．そのようにしてしまうと，ガードページを用意す
るには仮想アドレスのアンマップが必要となって使いづらくなります．明示的に
アンマップしない限り，物理メモリを参照するためです．

カーネルはトランポリンのページとカーネルの text 領域を \lstinline{PTE_R}
と\lstinline{PTE_X} のパーミッションでマップします．カーネルは，それらの
ページを読むことと実行ができます．カーネルは，それ以外のページ
は \lstinline{PTE_R} と \lstinline{PTE_W} でマップすることで，読み書きの両
方ができるようにします．ガードページは無効としてマップされます．


%% 
\section{Code: アドレス空間を作る}
%% 

アドレス空間とページテーブルの操作に関するコードのほとんど
は，\texttt{vm.c} \lineref{kernel/vm.c:1} に入っています．中心となる構造体
は \texttt{pagetable\_t} で，実はルートのページテーブル用ページへのポイ
ンタです．\texttt{pagetable\_t} は，カーネルのページテーブルか，プロセ
ス固有のページテーブルかのいずれかです．中心となる関数は，所与の仮想ア
ドレスに対応する PTE を見つけるための \texttt{walk} と，新しいマッピン
グのために PTE を設置する \texttt{mappages} です．カーネルのページテー
ブルを操作する関数は \texttt{kvm} から,ユーザのページテーブルを操作する
関数は \texttt{uvm} から始まる関数を使います．どちらでもない関数は両方
に使います．\texttt{copyout} と \texttt{copyin} は，システムコールの引
数として渡されたユーザの仮想アドレスを用いてデータを読み書きするために
使います．それらにカーネルからアクセスするには，対応する物理アドレスを
見つけるために明示的なアドレス変換が必要なので，\texttt{vm.c} に入って
います．

ブートシーケンスの初期で，\indexcode{main} は \indexcode{kvminit}
\lineref{kernel/vm.c:/^kvminit/}
を呼ぶことでカーネルのページテーブルを作ります．
これは，xv6 が RISC-V のページングを有効化する前ですので，アドレスは物理
アドレスを直接参照します．\lstinline{kvminit} はまず，ルートの
ページテーブル用のページをアロケートします．そのあと，\indexcode{kvmmap} を呼ぶこと
で，カーネルが必要とするアドレス変換をインストールします．ここで言うア
ドレス変換は次の領域を含みます: カーネルの命令列とデー
タ，\indexcode{PHYSTOP} までの物理メモリ，およびデバイスに対応するメモリ領
域．

\indexcode{kvmmap} \lineref{kernel/vm.c:/^kvmmap/} は \indexcode{mappages}
\lineref{kernel/vm.c:/^mappages/} を呼び，ある仮想アドレスの範囲から，対応する物理アド
レスの範囲へのマッピングをページテーブルにインストールします．この関数
は，範囲に含まれる仮想アドレスに対し，ページの周期ごとに，個々に処理を
行います．\lstinline{mappages} は
割り当てる仮想アドレスごとに \indexcode{walk} を呼び，対応す
る PTE のアドレスを見つけます．続いて，対応する PTE を初期化します．
すなわち，対応する物理ページ番号，所望のパーミッショ
ン(\lstinline{PTE_W}, \lstinline{PTE_X}, および \lstinline{PTE_R}) を
設定するとともに，\lstinline{PTE_V} をセットしてその PTE を有効化します
\lineref{kernel/vm.c:/perm...PTE_V/}.

\indexcode{walk} 
\lineref{kernel/vm.c:/^walk/}
は，RISC-V のページング用ハードウェアと
同じ方法で，仮想アドレスに対応する PTE を見つけます(図~\ref{fig:riscv_pagetable} を見てくださ
い)．\lstinline{walk} は，9ビットずつ使って 3 階層のページテーブルを下って
いきます．各階層では，仮想アドレスの 9 ビットを使って，次の階層の，もし
くは最終的なページの PTE を見つけます \lineref{kernel/vm.c:/pte.=..pagetable/}．もし PTE が無効
だった場合は，必要なページがアロケートされていないということです．も
し \lstinline{alloc} 引数がセットされていたら，\lstinline{walk} は新しいペー
ジテーブル用ページをアロケートして，その物理アドレスを PTE に入れま
す．\lstinline{walk} は，ツリーの最下層の PTE へのアドレスを返しま
す \lineref{kernel/vm.c:/return..pagetable/}．

上記のコードは，物理メモリがカーネルの仮想アドレス空間にダイレクトマッ
ピングされているという前提で動きます．たとえば，\texttt{walk} はページ
テーブルの階層を下っていくとき，次のページテーブルの（物理）アドレス
を PTE から見つけ \lineref{kernel/vm.c:/pagetable.=..pa.*E2P/}，そのアドレスを仮想アドレスとして
用いて次の階層の PTE を得ます \lineref{kernel/vm.c:/t..pte.=..paget/}．

\indexcode{main} は \indexcode{kvminithart} 
\lineref{kernel/vm.c:/^kvminithart/}
を呼んで
カーネルのページテーブルをインストールします．それにより，ルートの
ページテーブル用ページの物理アドレスが，\texttt{satp} レジスタに書き込まれます．
そのあと，CPU はページテーブルを用いてアドレス変換ができるようになります．
カーネルはダイレクトマッピングを使っているので，次に実行する命令の仮想アドレスは，
正しい物理メモリのアドレスを指しています．

\indexcode{procinit} \lineref{kernel/proc.c:/^procinit/} は，\lstinline{main} から呼び出される
もので，プロセスごとのカーネルスタックをアロケートします．各スタックを，スタッ
クのガードページの余裕を残しながら，\lstinline{KSTACK} で生成する仮想アド
レスにマップします．\lstinline{kvmmap} は，新たにマッピングする PTE をカー
ネルページテーブルに追加したあと，\lstinline{kvminithart} を呼んでそのカー
ネルページテーブルを \lstinline{satp} にリロードすることで，
ハードウェアに新しい \lstinline{PTE} を知らせます．

RISC-V の各コアは，最近のページテーブルエントリを 
\indextext{Translation Look-aside Buffer} (\indextext{TLB}) にキャッシュするため，もしキャッシュされた TLB
のエントリが期限切れになったときはそのことを教える必要があります．そうし
ないと，TLB に残っていた古いマッピングを利用してしまう可能性があります．
古いマッピングが指している物理ページは，すでに別プロセスがアロケートし
て使っているかもしれません．そのようなことが起きると，あるプロセスが別
プロセスのメモリを上書きできてしまう問題を引き起こします．
RISC-V は \indexcode{sfence.vma} 命令により，そのコアの TLB をフラッ
シュ (flush) することができます．xv6 は，\texttt{kvminithart} におい
て \texttt{satp} レジスタをリロードしたあと，ユーザ空間に戻る前に，ユー
ザページテーブルに切り替えるためのトランポリンコードの内部
で \texttt{sfence.vma} 命令を実行します \lineref{kernel/trampoline.S:/sfence.vma/}．

\section{物理メモリのアロケート}

カーネルは，実行時に，ページテーブル，ユーザメモリ，カーネルスタック，
およびパイプバッファのためにメモリのアロケートと解放を行わなくてはなり
ません．

xv6 は，カーネルの終端から \indexcode{PHYSTOP} の間の領域を，実行時のメモ
リアロケーションに利用します．4096 バイトのページ単位でアロケート・解放
を行います．どのページが使用可能であるか追跡するために，ページ自体をリ
ンクリストでつなぎます．ページをアロケートするときは，このリンクリストから
ページを 1 つ取り除きます．一方，ページの解放は，このリンクリ
ストに解放されたページをつなぎ加えます．

%% 
\section{Code: 物理メモリのアロケータ}
%% 

ページを確保するアロケータ (allocator) は，\texttt{kalloc.c}
\lineref{kernel/kalloc.c:1}
に入っています．アロケータのためのデータ構造は，割
り当てることができる物理メモリページの\textit{自由リスト} (free list) です．リス
トの要素は\indexcode{run} 構造体です \lineref{kernel/kalloc.c:/^struct.run/}. アロケータは，
そのデータ構造を入れるためのメモリを，どこから入手したらよいでしょう
か？\lstinline{run} 構造体は，その自由なページの中に記憶します．そのページ
には他に記憶するものが無いので，\lstinline{run} 構造体を入れておいてもよい
のです．自由リストはスピンロックで保護されま
す \linerefs{kernel/kalloc.c:/^struct.{/,/}/}．
リストとロックは構造体でくるまれており，どの
ロックがどの領域を守っていることが分かるようになっています．当面
は，ロックと \lstinline{lock} および\lstinline{acquire} の呼び出しのこ
とは気にしないでください．ロックは \ref{CH:LOCK}~章で詳しく説明をします．

\indexcode{main} 関数は，\indexcode{kinit} を呼ぶことで，アロケータを初期化し
ます \lineref{kernel/kalloc.c:/^kinit/}. 
\lstinline{kinit} は，自由リストにカーネルの終
端から \lstinline{PHYSTOP} までの全ページを入れて初期化します．
本来ならば，コ
ンフィギュレーション情報を解析することで，どれだけ物理メモリがあるのか
調べなくてはいけません．xv6 はそうするかわりに，そのマシン
は 128 MB のRAM を持つと決め打ちしま
す．\lstinline{kinit} は，\indexcode{freerange} を呼ぶことで，自由リストにメ
モリを追加します．これは，内部的には，ページごとに \indexcode{kfree} を呼
んで実現します．PTE は，4096 バイト境界に整列した物理アドレスだけを
指すことができます．
\lstinline{freerange} は，\indexcode{PGROUNDUP} を用いることで，整列した
物理アドレスだけを解放することを保証します．アロケータはメモリが空の状態で
開始しますが，\lstinline{kfree} により，ある程度がその管理に入ります．

アロケータは，アドレスを整数として扱って算術を行うことがありま
す(例：\lstinline{freerange} における全ページの横断)．一方で，アドレスをポ
インタとして扱うことで，メモリへの読み書きを行うこともあります（例：各
ページに入っている \lstinline{run} 構造体の操作）．このように，アドレス
を 2 つの意味で利用することが，アロケータのコードに C の型キャ
スト\index{type cast}がたくさん含まれる理由です．また，もう1つの理由は，メモリの解放・アロケートが，原
理的にメモリの型を変更するためです．

\lstinline{kfree} 関数 \lineref{kernel/kalloc.c:/^kfree/} は，まず，対応するメモリの全バ
イトを 1 で埋めます．あるコードが解放済みのメモリを読み込んだ場合 (すな
わち “dangling references” が置きた場合) に，過去のまともな内容ではなく，
ゴミを読み込むようなります．そうすることで，問題のあるコードが早期に破
綻することが期待できます．\lstinline{kfree}は，対象のページを自由リストの
先頭に付け加えるために次のようにします: \lstinline{pa} を \lstinline{run} 構
造体へのポインタにキャストし，自由リストの古い先頭を \lstinline{r->next}
に記録し，そして自由リストを \lstinline{r} にセットしま
す．\indexcode{kalloc} は自由リストの先頭の要素を取り除き，そしてその要
素をリターンします．

\section{プロセスのアドレス空間}

各プロセスは，独立したページテーブルを持ちます．xv6 がプロセスを切り替
えるときは，ページテーブルも合わせて切り替えます．図~\ref{fig:as} に示すように，
プロセスのユーザメモリは仮想アドレス 0 番から開始し，\texttt{MAXVA}
\lineref{kernel/riscv.h:/MAXVA/} まで増やすことができます．そうすることで，プロセスは
原理的には 256 ギガバイトまでのメモリを使うことができます．

プロセスが xv6 にさらなるメモリを要求したら，xv6 はまず\lstinline{kalloc}
を使って物理ページをアロケートします．そのあと，プロセスのページテーブル
に PTE を追加して，新たな物理ページを指し示すようにします．xv6 は，それ
らの PTE に対し\lstinline{PTE_W}, \lstinline{PTE_X}, \lstinline{PTE_R},
\lstinline{PTE_U}, および \lstinline{PTE_V} をセットします．ほとんどのプロ
セスは，ユーザのアドレス空間を使い切ったりはしません．xv6 は，未使用
の PTE に対しては，\lstinline{PTE_V} をクリア（ゼロ）のままにしておきま
す．

ページテーブルの使い方の良い例をいくつか見てみることにします．
第一に，異なるプロセスのページテーブルは，ユーザのアドレスを異なる物理
メモリのページに変換するので，各プロセスはプライベートなメモリを持つこ
とができます．第二に，各プロセスは，実際の物理メモリは不連続であったと
しても，0 から始まる連続した仮想アドレスを持つことができます．
第三に，カーネルは，トランポリンコードをユーザのアドレス空間の先頭に
マップします．そうすることで，物理メモリのあるページを，全てのアドレス空間
に出現させることができます．

\begin{figure}[t]
\center
\includegraphics[scale=0.5]{fig/processlayout.pdf}
\caption{あるプロセスにおけるユーザのアドレス空間と，そのスタックの初期状態}
\label{fig:processlayout}
\end{figure}

図~\ref{fig:processlayout} は xv6 において実行中のプロセスのユーザメモリのレイアウトを，詳
しく絵にしたものです．スタックは1ページで，\lstinline{exec} で作成された初
期の内容を表示しています．コマンドライン引数の文字列と，それらへのポイ
ンタの配列がスタックの先頭にあります．そのすぐ下に置いてある値
は，\lstinline{main} から開始したプログラムが，あたか
も\lstinline{main(argc, argv)} として呼び出されたかのように見せるためにあ
ります．

ユーザスタックが，アロケートしたスタックメモリからオーバーフローしたら
気づけるように，xv6 は無効なガードページをスタックのすぐ下に置いておきま
す．もしスタックがあふれてスタックの下のアドレスを使
おうとしたら，無効なマッピングへのアクセスがハードウェアにページフォル
トを生じさせます．現実世界のオペレーティングシステムには，あふれる前に，
ユーザスタックのメモリを自動でアロケートするものもあります．

\section{Code: sbrk}

\lstinline{sbrk} はプロセスがメモリを増やしたり減らしたりするためのシステ
ムコールです．これ
は，\lstinline{growproc} 関数 \lineref{kernel/proc.c:/^growproc/} で実装さ
れています．\lstinline{growproc} は，\lstinline{n} が正か負かに応じ
て，\lstinline{uvmalloc} もしくは \lstinline{uvmdealloc} を呼び出しま
す．\lstinline{uvmalloc} \lineref{kernel/vm.c:/^uvmalloc/} は，\lstinline{kalloc} で物理メモ
リをアロケートし，\lstinline{mappages} によりユーザページテーブルに PTE を
足します．\lstinline{uvmdealloc} は \lstinline{uvmunmap} \lineref{kernel/vm.c:/^uvmunmap/} を
呼びます．それは，\lstinline{walk} を用いて PTE を見つけ，\lstinline{kfree}に
より対応する物理メモリを解放します．

プロセスのページテーブルは，ハードウェアに対して仮想アドレスのマッ
ピング方法を指示するために利用しますが，そのプロセスにどの物理ページがアロケートされて
いるかを示す唯一の記録でもあります．\texttt{uvmunmap} にお
いてユーザメモリを解放するときに，ユーザページテーブルを見に行かなくてはいけない
のはそのためです．

%% 
\section{Code: exec}
%% 
\lstinline{exec} はアドレス空間の，ユーザに属する部分を作るためのシステム
コールです．その部分を，ファイルシステムに記録されたファイルを用いて初
期化します．\lstinline{exec} \lineref{kernel/exec.c:/^exec/} は，\ref{CH:FS}~章で説明するよう
に，\indexcode{namei} \lineref{kernel/exec.c:/namei/} により名前付きのバイナリのパスを
開きます．そのあと，ELF ヘッダを読み込みます．xv6 のアプリケーションは，
広く使われる \indextext{ELF フォーマット}で記述されており，それは \fileref{kernel/elf.h} で
定義されています．ELF バイナリは，ELF ヘッダである \indexcode{elfhdr} 構造
体 \lineref{kernel/elf.h:/^struct.elfhdr/} と，プログラムのセクションヘッダ \lstinline{proghdr}
構造体 \lineref{kernel/elf.h:/^struct.proghdr/} の列からなります．各 \lstinline{proghdr} は，メ
モリにロードされるべきプログラムの1セクションを記述します．xv6 のプログ
ラムには，プログラムセクションヘッダが 1 つしかありませんが，命令列やデータ
に対して別のセクションを割り当てるシステムもあります．

最初のステップは，ファイルが ELF バイナリであるかどうかの簡単なチェック
です．ELF バイナリの先頭は，4 バイトのマジックナンバー \lstinline{0x7F},
.code 'E',
.code 'L',
.code 'F',
あるい
は \indexcode{ELF_MAGIC} です 
\lineref{kernel/elf.h:/ELF_MAGIC/}．もしELF ヘッダが正しいマ
ジックナンバーを持つならば，\lstinline{exec} はそのバイナリが正しいフォー
マットを持つと考えます．

\lstinline{exec} は \indexcode{proc_pagetable} \lineref{kernel/exec.c:/proc_pagetable/} により，ユー
ザによる割当のない新しいページテーブルを得ます．そのあと，各 ELF セグメン
トのメモリを \indexcode{uvmalloc} \lineref{kernel/exec.c:/uvmalloc/} でアロケート
し，\indexcode{loadseg} \lineref{kernel/exec.c:/loadseg/} によりセグメントの内容をメモリ
にロードします．\lstinline{loadseg} は，\indexcode{walkaddr} を用いて
アロケートしたメモリの物理アドレスを調べ，ELF セグメントの各ページを書きこみます．
また，\indexcode{raedi} により，ファイルの読み込みを行います．

\lstinline{exec} が作る最初のプログラムである
\indexcode{/init} のプログラムセクションヘッダは以下の通りです．
%
\begin{footnotesize}
\begin{verbatim}
# objdump -p _init
user/_init:     file format elf64-littleriscv

Program Header:
    LOAD off    0x00000000000000b0 vaddr 0x0000000000000000 
                                      paddr 0x0000000000000000 align 2**3
         filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx
   STACK off    0x0000000000000000 vaddr 0x0000000000000000 
                                      paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
\end{verbatim}
\end{footnotesize}

プログラムのセクションヘッダにおけ
る \lstinline{filesz} は，\lstinline{memsz} よりも小さいときがあり，その差の
領域はファイルから読むこむかわりに，ゼロで埋めなくてはいけません（C の
グローバル変数のためです）．\lstinline{/init} においては，
\lstinline{filesz} は 2112 バイトで，\lstinline{memsz} は 2136 バイトです．
よって，\indexcode{uvmalloc} は 2136 バイトが入るのに十分な物理メモリを
確保しますが，\lstinline{/init} ファイルからは 2112 バイトしか読みません．

続いて，\indexcode{exec} はユーザスタックを初期化します．そのために，1ペー
ジだけ確保します．\lstinline{exec} は，引数の文字列をスタックの先頭に 1 つ
ずつコピーし，それらへのポインタを \indexcode{ustack} により記録します．さら
に，\indexcode{argv} リストとして \lstinline{main} に渡されるものの最後には，
ナルポインタを置きます．\lstinline{ustack} の最初の 3 エントリはフェイクの
リターンアドレス，\indexcode{argc}，および \lstinline{argv} へのポインタで
す．

\lstinline{exec} は，アクセス不可能なページを，先のスタックページのすぐ下
に置きます．そうすることで，1ページ以上使用しようとしたプログラムはフォ
ルトを起こすようにします．このアクセス不可能ページは，長すぎる引数にも
対処します．そのようなとき，\lstinline{exec} が引数をスタックへコピーす
るのに使う \indexcode{copyout} 関数 \lineref{kernel/vm.c:/^copyout/} は，コピー先のページ
がアクセス不可能であることに気づいて \-1 をリターンします．
新しいメモリイメージを準備するあいだ，もし \lstinline{exec} が不正なプログ
ラムセグメントなどのエラーを見つけたら，\lstinline{bad} というラ
ベルにジャンプし，新しいイメージを解放し，そして \-1 をリターンしま
す．\lstinline{exec} は，そのシステムコールが成功すると確認できるまで，古
いイメージの解放は待たなくてはいけません．もし古いイメージが無く
なってしまうと，システムコールは \-1 を返すことができないからです．
\lstinline{exec} のエラーが起きるのは，イメージを作る途中に限ります．もしイ
メージが完成したら，\lstinline{exec} は新しいページテーブルを手に入れ \lineref{kernel/exec.c:/pagetable.=.pagetable/}，古
いものを解放することができます \lineref{kernel/exec.c:/proc_freepagetable/}．

\lstinline{exec} は ELF ファイルに入っているバイト列を，ELF ファイルが指定
するアドレスに従ってメモリにロードします．ユーザもしくはプロセスは, 好
きなアドレスを ELF ファイルに書くことができます．ELF ファイルは事故もし
くは悪意によってカーネルを指すことがありうるので，\lstinline{exec} には危
険性があります．カーネルの不注意は，クラッシュから悪意を持ったカーネル
の分離メカニズムの迂回（すなわちセキュリティのエクスプロイト）にいたる
までさまざまな結果をもたらします．xv6 は，いくつものチェックを行うこと
で，そのリスクを避けます．たとえば，
%
\lstinline{if(ph.vaddr + ph.memsz < ph.vaddr)} 
%
は，加算結果が64ビット整数からあふれるかどうかをチェックします．ありう
る危険は次のようなものです: ユーザが選んだアドレスとし
て \lstinline{ph.vaddr} が入った ELF バイナリを作ることができて，か
つ \lstinline{ph.memsz} が十分大きくて加算結果があふれ
て \lstinline{0x1000}になってしまう場合，あふれた結果が正しい値に見えて
しまう．xv6 の古いバージョンでは，ユーザのアドレス空間にはカーネルが
（ユーザモードでは読み書きできない状態で）マップされていたので，ユーザ
はカーネルのメモリに対応するアドレスを選ぶことで， ELF バイナリのデータ
からカーネルへデータをコピーできました．この RISC-V のバージョンの xv6
では，そのようなことは起きません．カーネルは独自のページテーブルを持っ
ており，\lstinline{loadseg} はカーネルではなくプロセスのページテーブル
に対するロードを行うためです．

カーネル開発者は，重要なチェックを怠ってしまうことがあります．そして，
現実世界のカーネルでは，カーネル特権の奪取につながるチェックの不在に
長い歴史があります．xv6 にも，ユーザレベルプログラムからカーネルに届く
データの検証が完全でない部分があり，悪意あるユーザプログラムが xv6 の
分離を迂回するエクスプロイトを作ることができるかもしれません．

%% 
\section{世の中のオペレーティングシステム}
%% 

ほとんどのオペレーティングシステムと同じく，xv6 はページングハードウェ
アをメモリ保護とマッピングに使います．ほとんどオペレーティングシステム
は，xv6 よりはるかに洗練されたページングの使い方をします．たとえば，xv6
にはディスクからのデマンドページング，\texttt{fork} におけるコピーオン
ライト，ページの遅延確保（lazily-allocated pages）, 自動で伸びるスタッ
ク，メモリマップドファイル (memory-mapped file) などがありません．

RISC-V は物理アドレスのレベルでの保護もサポートしますが，xv6 はその機能を
使いません．

メモリが大量にあるマシンにおいては，RISC-V のスーパーページ（サイズの大
きいページ）にご利益があるかもしれません．一方，物理メモリが小さいとき
は，小さいページを使うほうが有利です．ページ確保やディスクへのページ
アウトを細かい粒度で行うことができるからです．たとえば，メモリを8キロバイト
使うプログラムがあった場合，そのようなプログラムに，4メガのスーパーページ全体を
割り当てるのは無駄です．大きなページは，RAM をたくさん積んだマシンにおいて
ご利益があり，ページテーブル操作のオーバーヘッドを減らせる可能性があります．


xv6 カーネルには，\texttt{malloc} のような小さなオブジェクト用のメモリアロケータ
がありません．そのためカーネルは，動的なメモリ確保が必要な，洗練
されたデータ構造を使うことができません．

メモリ確保は，大昔のホットトピッ
クでした．予測できない将来のリクエストに備えて，限られたメモリを効率的
に使いたい，というのが基本的な問題でした~\cite{knuth}．しかし今日では，空間的な効率性よ
りも速度が優先されます．また，より発展したカーネルは，xv6 のよう
な4096 バイトブロック単位ではなく，サイズの異なる小さなメモリブロックを
大量に確保します．実世界におけるカーネルのアロケータは，大きなメモリだけでなく，
小さなメモリのアロケートの面倒も見る必要があるのです．

%% 
\section{練習問題}
%% 

\begin{enumerate}
  
\item RISC-V のデバイスツリーを解析し，そのコンピュータが持つ物理メモリの量を求めてください．

\item \lstinline{sbrk(1)} を呼ぶことで，アドレス空間を 1 バイト増加させる
  ユーザプログラムを書いてください．そのプログラムを実行し，\lstinline{sbrk} 
  呼び出しの前後におけるページテーブルを調査してください．カーネルがアロケートした
  空間はどれだけでしょうか？新しいメモリに対応する \lstinline{pte} の中身は
  どうなっているでしょうか？

\item xv6 を改造して，カーネルがスーパーページを使えるようにしてください．

\item xv6 を改造して，ユーザプログラムがナルポインタをデリファレンスし
  たときにフォールトを受け取るようにしてください．すなわち，全てのプログラムに
  おいて，仮想アドレス 0 番がマップされないようにしてください．

\item Unix における \lstinline{exec} は，伝統的に，シェルスクリプトを
  特別扱いします．実行するファイルが \lstinline{\#!} から始まる場合，
  その 1 行目はファイルを解釈するためのプログラムと認識されます．
  たとえば，\lstinline{myprog arg1} を実行するために \lstinline{exec} が
  呼ばれ，\lstinline{myprog} の 1 行目が \lstinline{\#!/interp} で
  あったら，\lstinline{exec} は \lstinline{/interp myprog arg1} という
  コマンドで \lstinline{/interp} を実行します．xv6 に，以上の機能を実装してください．

\item カーネルに，アドレス空間のランダム化を実装してください．

\end{enumerate}

