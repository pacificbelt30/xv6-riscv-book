\chapter{ファイルシステム}
\label{CH:FS}
%         is it process or kernel thread?
% 
%         the logging text (and some of the buffer text) assumes the reader
%         knows a fair amount about how inodes and directories work,
%         but they are introduced later.
% 
% 	have to decide on processor vs CPU.
% 	
% 	be sure to say buffer, not block 
% 
% 	Mount

ファイルシステムはデータを整理して保存するためにあります．ファイルシ
ステムは通常，ユーザやアプリケーション間のデータの共有や，再起動後にも
データを使うための\indextext{永続性}を提供します．

xv6 のファイルシステムは，Unix 風のファイル，ディレクトリ，パス名（\ref{CH:UNIX}~章
を見てください），\texttt{virtio} ディスクへの永続的な保存（\ref{CH:TRAP}~章をみてく
ださい）などを提供します．ファイルシステムは，いくつかの課題
を解決する必要があります．
\begin{itemize}
\item ファイルシステムは，ディスク上に名前付きディレクトリとファイルの
  ツリーを表現するためのデータ構造を必要とします．それを用いて，どのブ
  ロックがどのファイルの中身を保持するかや，ディスクのどの領域が空いてい
  るかを記録します．

\item ファイルシステムはクラッシュリカバリをサポートしなくてはいけませ
  ん．すなわち，クラッシュ（たとえば電源不良）が起きたとしても，ファイ
  ルシステムは再起動後に正しく動かなくてはいけません．危険なのは，クラッ
  シュが更新の列に割り込むことで，ディスク上のデータ構造から一貫性が失
  われることです（例：あるブロックがあるファイルで使われているのに，未
  使用のマークがついてしまう）．

\item 複数のプロセスが，同時にファイルシステムの操作をすることがありえ
  ます．そのため，ファイルシステムのコードが調整をして，不変量を管理し
  なくてはいけません．

\item ディスクへのアクセスは，メモリへのアクセスと比べてケタ違いに低速
  です．そのため，ファイルシステムはよく使われるブロックのキャッシュを
  メモリ上に作り，管理する必要があります．
\end{itemize}

この章の残りは，xv6 がどのように上記の課題を解決するかを説明します．

%% 
%%  -------------------------------------------
%% 
\section{概要}

xv6 のファイルシステムの実装は，図~\ref{fig:fslayer} に示す 7 層に整理でき
ます．ディスク層は，\texttt{virtio} ハードドライブ上のブロックの読み書
きを行います．バッファキャッシュ層は，ディスク上のブロックをキャッシュ
するとともに，そのアクセスを同期化して，ある特定のブロックに入ったデー
タを変更できるのが 1 度に 1 プロセスだけになるようにします．ロギング層は，
より上位の層のために，複数ブロックにまたがる更新を\indextext{トランザクション}にまとめま
す．そうすることで，クラッシュしたとき，それらの更新がアトミック
になる（すなわち，全て更新するかまったくしないかのどちらかになる）よう
にします．inode 層はファイルを提供します．ファイルは，ユニーク
な i-number を持つ \indextext{inode} と，そのファイルの情報を持つい
くつかのブロックで表現されます．ディレクトリ層は，ディレクトリを提供し
ます．ディレクトリとは特別な種類の inode のことで，その中身は
ディレクトリエントリの列で，それぞれがそのファイルの名前と\texttt{i}番
号を含んでいます．パス名層は，\texttt{/usr/rtm/xv6/fs.c} のような階層化
されたパス名を提供し，パス名を解決するための再帰的な参照を行います．ファ
イルディスクリプタ層は，たくさんの Unix 資源を，ファイルシステムのイン
タフェースで抽象化します（例：パイプ，デバイス，ファイルなど）．そうす
ることで，アプリケーションプログラマの仕事を単純化します．


\begin{figure}[t]
\center
\includegraphics[scale=0.5]{fig/fslayer.pdf}
\caption{xv6 ファイルシステムの層}
\label{fig:fslayer}
\end{figure}

ファイルシステムには，inode やファイルの中身を記録するブロック
を，ディスク上のどこに記録するかという計画が必要です．そのために，xv6
はディスクを，図~\ref{fig:fslayout} に示すように複数のセクションに分割します．ファイル
システムは 0 番ブロックは使いません（そこには，ブートセクタが入っていま
す）．1 番ブロックは\indextext{スーパーブロック}と呼ばれます．そこには，ファイルシ
ステムに関するメタデータが入っています（ブロック数でのファイルサイズ，
データブロックの個数，inode の個数，ログに入っているブロックの
数）．2 番以降のブロックにはログが入ります．ログの後ろにあるの
は inode で，1つのブロックに複数の inode が入っていま
す．そのあとに来るのはビットマップブロックで，どのブロックが使用中かを
追跡するのに使います．残りのブロックはデータブロックで，ビットマップブロックに
おいて未使用とマークされているか，あるいはファイルやディレクトリの中身を
保持しています．スーパーブロックは，\indexcode{mkfs} と呼ばれる独立した
プログラムによって書き込まれます．それが，ファイルシステムを初期化します．

この章の残りは，バッファキャッシュからはじめて，各層の説明をしていきます．
低層でよく考えられた抽象化を選ぶことで，上層の設計が楽になるとうシチュエーションを
見ることができます．
%% 
%%  -------------------------------------------
%% 
\section{バッファキャッシュ層}

バッファキャッシュには 2 つのしごとがあります．(1) ディスクブロックへのアクセスを
同期化することで，唯一のコピーのみがメモリに入り，1度に1つのカーネルスレッド
だけがそのコピーを使うようにすること．(2) よく使われるブロックをキャッシュすることで，
遅いディスクから何度も読まなくてよくすること．コードは \texttt{bio.c} です．

バッファキャッシュが提供する主なインタフェース
は \indexcode{bread} と \indexcode{bwrite} です．前者はあるブロックのコピーを
メモリ上で読み書きできる \texttt{buf} を取得します．後者は，更新された
バッファをディスク上の適切なブロックに書き戻します．カーネルスレッドは，
使い終わったバッファを \indexcode{brelse} で解放しなくてはいけません．
バッファキャッシュは，バッファごとのスリープロックを使うこと
で，1 度に 1 つのスレッドだけが各バッファ（すなわち各ディスクブロック）
を使えるようにします．\texttt{bread} はロックされたバッファをリターン
し，\texttt{brelse} はロックを解放します．

バッファキャッシュの話にもどりましょう．バッファキャッシュは，ディス
ク上のブロックをたくわえるバッファを，ある決まった数だけ持っています．
それはつまり，ファイルシステムがまだキャッシュに入っていないブロックを
要求したら，今は別のブロックのために使われている
バッファを再利用しなくてはいけないことを意味します．バッファキャッシュは，
新しいブロックのために，最近使用頻度が低かった(least recently used) バッ
ファを再利用します．最近使用頻度が低かったバッファは，
将来使われる可能性がもっとも低いだろうと考えるわけです．

\begin{figure}[t]
\center
\includegraphics[scale=0.5]{fig/fslayout.pdf}
\caption{xv6 ファイルシステムの構造}
\label{fig:fslayout}
\end{figure}
%% 
%%  -------------------------------------------
%% 
\section{Code: バッファキャッシュ}

バッファキャッシュはバッファの 2 重リンクリストです．\texttt{main} 関
数が呼ぶ \indexcode{binit} 関数が
\lineref{kernel/main.c:/binit/}，静的配
列 \texttt{buf}を使って，要素数 \texttt{NBUF} のリストを初期化します
\linerefs{kernel/bio.c:/Create.linked.list/,/^..}/}．
バッファキャッシュへのそれ以外のアクセスは，\texttt{buf} 配列ではなく，
\indexcode{bcache.head} を介してリンクリストとして行います．

バッファには 2 つの状態フィールドが関連付けられていま
す．\indexcode{valid} フィールドは，そのバッファがあるブロックのコピーを保
持していることを表します．\indexcode{disk} フィールドは，バッファの中身が
ディスクに受け渡されたことを表します．これは，バッファを変える可能性が
あります（例：ディスクから読んだデータを \texttt{data} に書き込む）．

\texttt{bread} 
\lineref{kernel/bio.c:/^bread/}
は \indexcode{bget} を呼んで，所望の
セクタに対応するバッファを取得します
\lineref{kernel/bio.c:/b.=.bget/}．もし，バッファ
をディスクから読まなくてはいけない場合には，\texttt{bread} は バッファ
を返す前に \indexcode{virtio_disk_rw} により読み込みを行います．

\texttt{bget} 
\lineref{kernel/bio.c:/^bget/}
はバッファリストをスキャンし，
与えられたデバイスとセクタ番号を探します
\linerefs{kernel/bio.c:/Is.the.block.already/,/^..}/}．
もし見つかったら，\indexcode{bget} はそのバッファのスリープロックを取得します．
\texttt{bget} は，そのあとでロック済みバッファを返します．

与えられたセクタに対応するバッファが無かったら作る必要があります．そのた
めには，別のセクタのために使われているバッファの再利用が必要かもしれませ
ん．\indexcode{bget} はバッファリストを再度スキャンし，使われていないバッ
ファ (\texttt{b->refcnt = 0}) を探します．そのようにして使えるバッファ
が見つかったら，\texttt{bget} は新しいデバイスとセクタ番号を記録するために
バッファのメタデータを変更し，そしてスリープロックを取得します．
\texttt{b->valid = 0} と代入することで，\texttt{bread} は
バッファの古い内容を使わずに，ディスクからそのブロックのデータを読み出します．

各ディスクのセクタごとに，キャッシュされたバッファは最大でも 1 個であるこ
とが重要です．そうすることで，バッファを読む人が書き込みに気づくことが
できます．また，ファイルシステムがバッファへのロックにより同期化を行っ
ていることも理由の1つです．\texttt{bget} は，この不変量を保証するため，
最初のループでブロックがキャッシュされているかどうか調べるところか
ら，2つ目のループで（\texttt{dev}, \texttt{backno}, およ
び \texttt{refcnt} をセットして）ブロックがキャッシュされたと宣言される
まで，\texttt{bache.lock} を保持し続けます．そうすることで，ブロックが
存在するか確認して，もし存在しないならばそのブロックが入るバッファを取
得するという一連の処理がアトミックになります．

\texttt{bget} は，\texttt{bcache.lock} クリティカルセクションの外でバッ
ファのスリープロックを取得しても安全です．なぜなら，\texttt{b->refcnt}
が非ゼロでであることにより，バッファが別のディスクブロックのために再利
用されることはないからです．スリープロックは，ブロックのバッファされた
内容の読み書きを保護します．それに対し，\texttt{bcache.lock} はどのブ
ロックがキャッシュされているかという情報を保護します．

もし全てのバッファが使用中だったら，同時にファイルのシステムコールを実
行しているプロセスが多すぎるということです．\texttt{bget} はパニックを
起こします．より穏やかな対応として，バッファが使用可能になるまで
スリープする方法もありえますが，デッドロックの可能性があります．

\indexcode{bread} が（必要に応じて）ディスクからの読み込みを完了し，バッファ
を呼び出し元にリターンしたら，その呼び出し元はバッファを排他的に利用し
て読み書きができます．もし呼び出し元がバッファを書き換えたら，バッファ
を解放する前に，\indexcode{bwrite} を呼んでデータをディスクに書きもどす必
要があります．\texttt{bwrite}
\lineref{kernel/bio.c:/^bwrite/} は，
\indexcode{virtio_disk_rw} を呼んでディスクのハー
ドウェアとやり取りをします．

バッファを使い終わったら \indexcode{brelse} を呼んで
解放しなくてはなりません．(\texttt{brelse} は ``b-release'' を短縮した
ものであり，暗号じみていますが学ぶ価値があります．Unix に起源があ
り，BSD, Linux, および Solaris でも使われています)．\texttt{brelse}
\lineref{kernel/bio.c:/^brelse/}
はスリープロックを解放し，バッファをリンクリストの先頭に付け加えます
\linerefs{kernel/bio.c:/b->next->prev.=.b->prev/,/bcache.head.next.=.b/}．
バッファを付け加えると，リスト
は，使われた（すなわち解放された）タイミングが新しい順にバッファを整列
します．リストの先頭バッファはもっとも最近使われたもので，最後尾はもっとも使わ
れていないものです．\texttt{bget} の 2 つのループがその性質を利用します．
既存のバッファを探そうとすると，最悪の場合ではリスト全体を見る必要があ
ります．しかし，最近使われたバッファから順に調べれば（すなわ
ち\texttt{bcache.head} からはじめて順にリストをたどれば），参照によ
い局所性があれば，スキャン時間を減らすことができます．一方，再利用する
バッファを探すときは，リストを逆向きにたどれば，最近もっとも使われていない
バッファを見つけることができます．

%% 
%%  -------------------------------------------
%% 
\section{ロギング層}

ファイルシステム設計でもっともおもしろい問題の 1 つはクラッシュリカバリ
です．ファイルシステムのオ
ペレーションの多くは，ディスクへの複数回のアクセスが必要となるので，
途中でクラッシュすると，ディスク上のファイルシステムが一貫性
のない状態になってしまうことがあります．たとえば，ファイルのトランケーショ
ン（ファイルの長さをゼロにして，中身を保存していたブロックを解放するこ
と）の途中でクラッシュが起きた場合を考えてみましょう．ディスクへの書き
込み順序によりますが，クラッシュにより，解放済みとマークされたブロッ
クを使い続ける inode ができてしまうか，もしくはアロケートされているが
どこからも参照されていないコンテンツ用ブロックができてしまいます．

後者は比較的マシですが，解放済みブロックを参照する inode は再
起動後に深刻な問題を引き起こす可能性があります．再起動後，カーネルはそ
のブロックを別のファイルのためにアロケートする可能性があります．そうする
と，2つの異なるファイルが，意図せず同じブロックを指すことになります．も
し xv6 が複数ユーザをサポートしていたとしたら，この状況はセキュリティ上
の問題になります．なぜなら，古いファイルの所有者は，別のユーザが持つ新
しいファイルのブロックに対して読み書きができてしまうからです．

xv6 はファイルシステムのオペレーション途中でのクラッシュの問題を，シン
プルなロギングで解決します．xv6 のシステムコールは，ディスク上
のファイルシステムのデータ構造を直接読み書きすることはありません．
そのかわり，ディ
スク上の\indextext{ログ}に記入するのです．システムコールは，全ての書き込み処理をログ
に書き終えたら，特別な\indextext{コミット}記録をディスクに書き込む
ことで，ログが完全なオペレーションを含むことマークをつけます．それから，
書き込み内容をディスク上のファイルシステムのデータ構造へ
コピーします．書き込みが終わったら，システムコールはディスク上
のログを消去します．

もしシステムがクラッシュして再起動した場合，ファイルシステムは
次のようにしてクラッシュから復帰します．もし
ログに完全なオペレーションが入っているとマークされていたら，復帰のためのコードが
動き，ディスク上のファイルシステムの適切な場所へデータをコピー
します．一方，オペレーションが完全であるとマークされていない
ログは無視します．復帰のためのコードは，最後にログを消去します．

なぜ，xv6 のログを使うと，ファイルシステムのオペレーション途中のクラッ
シュ問題が解決するのでしょうか？もしオペレーションのコミット前にクラッ
シュが起きたら，ディスク上のログは完全とマークされないので，復帰用のコー
ドはそれを無視します．その結果，ディスクは，そのオペレーションが始まる
前の状態にもどります．コミットのあとにクラッシュが起きたら，復帰用のコー
ドが書き込みを再度行います．その際，クラッシュ前に行っ
た書き込みを繰り返すこともありえます．いずれの場合でも，ログはオペレー
ションを（クラッシュに関して）アトミックにします．復帰のあと，オペレー
ションによる書き込みは，全体がディスク上にあるか，もしくはまったく無い
かのいずれかになります．

%% 
%% 
%% 
\section{ログの設計}

ログは，スーパーブロックで指定する定位置に置かれます．ログはヘッダブロッ
クと，更新されたブロックのコピー (ログブロック) の列からなります．ヘッ
ダブロックには，各ログブロックのセクタ番号の配列と，ログブロックのカウ
ント数が入っています．ディスク上のヘッダブロックのカウント数がゼロであ
るとき，ログにはトランザクションが記録されていません．一方，カウント数
が非ゼロであるとき，ログはコミットされた完全なトランザクションを保存し
ており，それはカウント数分のブロックからなります．xv6は，トランザクショ
ンをコミットするときにヘッダブロックへ書き込みを行い，ログブロックをファ
イルシステムへコピーしたあとにカウント数をゼロに戻します．トランザクショ
ンの途中でクラッシュが起きると，ヘッダブロックのカウント数をゼロのまま
になります．一方，コミット後にクラッシュが起きると，カウント数は非ゼロ
となります．

各システムコールのコードが，クラッシュに関してアトミックにすべき書き込
み列の範囲を決めます．複数のプロセスによるオ
ペレーションを並行処理するため，ロギングシステムは複数のシステムコール
による書き込みを 1 つのトランザクションに固めることがあります．
よって，1 つのコミットは，複数のシステムコールの書き込みを含むこ
とがあります．システムコールがトランザクションをまたがないように，
他のファイルシステムのシステムコールが動いていないときに限りコミットを
行います．

複数のトランザクションをまとめてコミットするアイディアは，
\indextext{グループコミット} (group commit) と呼ばれます．グループコミットは，ディスクオペレーショ
ンの数を減らす効果があります．コミットのための固定コストが，複数のオペ
レーションで割り勘になるからです．グループコミットにより，ディスクシス
テムはよりたくさんの書き込みを並行して行えるようになります．たとえば，
ディスクが一回転するあいだに全てを書き込むような場合で
す．xv6 の \texttt{virtio} はそのような\indextext{バッチ処理}は行いません
が，xv6 のファイルシステムの設計では原理的にそのようなことが可能です．

xv6 は，固定長のディスク領域を，ログを保存するために使います．あるトラ
ンザクションが書き込むのブロック数は，その
領域に収まる必要があります．そのために次の 2 つの制限が導かれ
ます．1つ目の制限は，どのシステムコールも，ログよりも大きいサイズの書き
込みはできないというものです．これは，ほとんどのシステムコールでは
問題になりませんが，\indexcode{write} と \indexcode{unlink} の2 つは，潜在的に
たくさんのブロックを書き込む可能性があります．大きなファイルの書き込み
は，データブロックだけでなく，ビットマップブロックや inode へ
の大量の書き込みを生じるからです．同様に，大きなファイルのアンリンクは，ビッ
トマップブロックや inode への大量の書き込みを生じま
す．xv6 の\texttt{write} システムコールは，大きい書き込みを，ログに収まる
小さい書き込みに分解します．xv6 では \texttt{unlink} は問題になりません．
なぜなら，xv6 はビットマップブロックを1つしか使わないからです．
ログのためのスペースが限られることの 2 つ目の制限は，あるシステムコー
ルの書き込みが，ログの残りのスペースに収まる場合でなければ，そのシステ
ムコールを始めることができないというものです．

%% 
%% 
%% 
\section{Code: ロギング}

システムコールにおいてログを使用する典型例は以下のようなものです．
\begin{lstlisting}[]
  begin_op();
  ...
  bp = bread(...);
  bp->data[...] = ...;
  log_write(bp);
  ...
  end_op();
\end{lstlisting}

\indexcode{begin_op} 
\lineref{kernel/log.c:/^begin.op/}
は，ロギングシステムがコミットし
ておらず，かつそのシステムコールによる書き込みが入るログ領域が空
くまで待ちます．\texttt{log.outstanding} は，ログ領域を予約した
システムコール数をカウントします．使用されているスペース
は\texttt{log.outstanding}$\times$\texttt{MAXOPBLOCKS}で
す．\texttt{log.outstanding} を増加させることで，スペースを予約するとと
もに，そのシステムコールの間にコミットが発生しないようにします．コード
は，各システムコールのコードが \texttt{MAXOPBLOCKS} ブロックを使用する
かもしれないと保守的に想定します．

\indexcode{log_write}
\lineref{kernel/log.c:/^log.write/}
は，\indexcode{bwrite} のプロキシと
して動作します．それは，ブロックのセクタ番号をメモリに記録し，ディ
スク上のログにスロットを予約し，ブロックキャッシュ内のバッファをピン留
めしてキャッシュが退去 (evict) されないようにします．ブロックは，コミッ
トが済むまでキャッシュに留まる必要があります．キャッシュされ
たコピーが，行われた変更の唯一の記録だからです．コミットするまで，それらをディ
スク上には書き込めません．一方，同じトランザクションの
他の読み込みは，その変更を見ることができなくてはいけません．
\texttt{log\_write} は，トランザクション内の特定のブロックに何度
も書き込みが行われたらそのことに気づき，ログの同じスロットにあるブ
ロックをアロケートします．この最適化は，よく\indextext{吸収} (absorption) と呼ばれ
ます．たとえば，さまざまなファイルの inode を含むディスクブロッ
クは，1 つのトランザクションの中で何度も書き込まれることが一般的です．
複数のディスク書き込みを 1 つに吸収することで，ファイルシステムはログの
スペースを節約するとともに，1つのコピーだけがディスクに書き込まれるよう
にすることで性能向上を達成できます．

\indexcode{end_op}
\lineref{kernel/log.c:/^end.op/}
はまず，未解決な (outstanding
な) システムコール数を減らします．その数がゼロになった
ら，\texttt{commit()} を呼んでそのトランザクションをコミットします．こ
のプロセスには 4 つのステージがあります．\texttt{write\_log()}
\lineref{kernel/log.c:/^write.log/}
はトランザクションで変更される各ブロックを，バッファ
キャッシュからディスク上のログのスロットへコピーしま
す．\texttt{write\_head()} \lineref{kernel/log.c:/^write.head/} はヘッダブロックをディス
クに書き込みます．これがコミットする瞬間です．この書き込みが終わっ
たあとにクラッシュが起きると，ログの中身を再度実行する復元が起きま
す．\indexcode{install_trans} 
\lineref{kernel/log.c:/^install_trans/}
はログの各ブロックを読み，
ファイルシステムの適切な場所に書き込みます．最後に，\texttt{end\_op} が
カウント数がゼロのログヘッダを書き込みます．この処理は，次のトランザク
ションがログブロックに書き込みを行う前に行う必要があります．そうしない
と，今回のログヘッダと，次のトランザクションのログブロックという誤った組
み合わせでクラッシュ後の復元が行われてしまうからです．

\indexcode{recover_from_log} 
\lineref{kernel/log.c:/^recover_from_log/}
は，\indexcode{initlog}
\lineref{kernel/log.c:/^initlog/},
から呼び出されます．\texttt{initlog} は, 起動時
に最初のプロセスが実行する前に \lineref{kernel/proc.c:/fsinit/}，\indexcode{fsinit}
\lineref{kernel/fs.c:/^fsinit/}
が呼び出します．\texttt{recover\_from\_log} はログヘッ
ダを読み，もしそれがコミット済みのトランザクションを含むのであれば
\texttt{end\_op} のマネをします．

ログを使用する 1 つの例は，\indexcode{filewrite}
\lineref{kernel/file.c:/^filewrite/}.
にあります．そのトランザクションは次のようなものです．
\begin{lstlisting}[]
      begin_op();
      ilock(f->ip);
      r = writei(f->ip, ...);
      iunlock(f->ip);
      end_op();
\end{lstlisting}
このコードは，書き込みを，数セクタていどの小さなトランザクションに分解
するループにつつまれています．そうすることでログを圧迫しないようにし
ています．\indexcode{writei} を呼ぶと，そのトランザクションの一部として，
たくさんのブロックを書き込みます．ファイルの inode，1つもしく
は複数のビットマップブロック，そしていくつかのデータブロックです．

%% 
%% 
%% 
\section{Code: ブロックアロケータ}

ファイルとディレクトリの中身はディスクブロックに保存されますが，そのた
めのディスクブロックは，使用可能なプールからアロケートする必要がありま
す．xv6 のブロックアロケータは，使用可能なディスクを，1 ビットが 1 ブロッ
クに対応するビットマップとして管理します．ビットが 0 であることは対応す
るブロックが使用可能であること，ビットが 1 であることは使用中であること
をそれぞれ意味します．\texttt{mkfs} というプログラムが，ブートセクタ，
スーパーブロック，ログブロック，inode ブロック，およびビットマッ
プブロックに対応するビットをセットします．

ブロックアロケータは 2 つの関数を提供します．新たなディスクブロックをア
ロケートする \indexcode{balloc} と，ブロックを解放する \indexcode{bfree} です．
\lineref{kernel/fs.c:/^..for.b.=.0/}
にある \texttt{balloc} のループは，0 番から（そのファ
イルシステムに入っているブロックの総数である）\texttt{sb.size} 番のブロッ
クに向けて順番に調べていきます．\texttt{balloc} は対応するビットマップ
上のビットがゼロ，すなわち未使用のブロックを探します．そのようなブロッ
クを見つけると，\texttt{balloc} はビットマップを更新し，そのブロックを
返します．効率のために，ループは 2 重に分かれています．外側のループは
ビットマップのビットを含むブロックを順に読みます．続く内側のループは，
あるビットマップブロックの，全ての\texttt{BPB} ビットをチェックします．
あるプロセスが，1度に1つのビットマップブロックしか使えないようにバッ
ファキャッシュが制御することで，2 つのプロセスが同時にブロックをアロケー
トしようとして生じる競合を防ぎます．

\texttt{bfree}
\lineref{kernel/fs.c:/^bfree/}
は所望のビットマップブロックを見つけ，
その中の所望のビットをクリアします．くり返しになります
が，\texttt{bread} と \texttt{brelse} による排他的な取り扱いにより，
明示的なロックは不要です．

本章の残りで記述するコードと同様に，\texttt{balloc} と \texttt{bfree}
はトランザクションの内部で呼ばれる必要があります．
%% 
%%  -------------------------------------------
%% 
\section{inode 層}

\indextext{inode} という用語は，2 つの関連した意味を持ちます．一方で，ファ
イルサイズやデータブロック番号のリストを含むディスク上のデータ構造を指
すことがあります．またもう一方で，メモリ上の inode を指すこと
もあります．これは，ディスク上の inode をコピーし，カーネル向
けの追加情報を付け加えたものです．

ディスク上の inode は，inode ブロックと呼ばれるディスク上の連続した領域
に格納されています．全ての inode は同じサイズであるため，ある数字 $n$
が与えられたとき，容易に $n$ 番目の inode をディスク上で見つけることが
できます．実際，この番号$n$ は inode 番号，もしくは i-number と呼ば
れ，inode を識別するのに用います．

ディスク上の inode は，\indexcode{dinode} 構造体
\lineref{kernel/fs.h:/^struct.dinode/}
が定義します．\texttt{type} フィールドにより，ファイル，ディレクトリ，
および特殊ファイル（デバイス）を区別します．\texttt{type} が 0 であるこ
とは，そのディスク上の inode が使用可能であることを示しま
す．\texttt{nlink} フィールドは，その inode を参照するディレク
トリの個数をカウントしており，ディスク上の inode とデータブロッ
クをいつ解放すべきかを知るために使います．\texttt{size} フィールド
は，そのファイルの中身のバイト数を記録します．\texttt{addr} 配列は，そ
のファイルの中身を保存するブロックのブロック番号を記
録します．

カーネルは，よく使う inode をメモリにいれておきま
す．\indexcode{inode} 構造体
\lineref{kernel/file.h:/^struct.inode/}
が，\texttt{dinode} のメモ
リ上のコピーです．カーネルがメモリ上に inode を置いておくのは，
それを指す C のポインタが存在するときにかぎります．\texttt{ref} フィー
ルドは，メモリ上 inode を参照する C ポインタの数をカウント
するためにあります．もし参照カウントがゼロになったら，カーネル
はその inode をメモリから破棄します．\indexcode{iget} と \indexcode{iput}
関数は，inode へのポインタを取得し，参照カウントを変更しま
す．inode を指すポインタを使うのは，ファイルディスクリプタ，カ
レントディレクトリ，および \texttt{exec} などの一時的なカーネルのコード
などです．

xv6 の inode のコードには，4 つのロックもしくはロックに類似し
たメカニズムがあります．\texttt{icache.lock} は，「inode は
キャッシュ内に最大でも1個しか存在しない」および「キャッシュされ
た inode の \texttt{ref} フィールドは，キャッシュされ
たinode を指すメモリ内ポインタの数を示す」という不変量を
保護します．各メモリ内 inode は，スリープロックのための
フィールドを持ち，inode の各フィールド（たとえばファイルの長さ）
や，その inode 内のファイル・ディレクトリのコンテンツブロック
が排他的にアクセスされることを保証しま
す．inode の \texttt{ref} がゼロより大きければ，システムはそ
の inode のキャッシュを維持します．すなわち，そのキャッシュの
エントリを別の inode のために再利用しません．最後に，
各 inodeは \texttt{nlink} フィールド（ディスク上，およびキャッ
シュされているならメモリ上のコピー）を持ち，そのファイルを参照するディ
レクトリエントリの数をカウントします．xv6 は，\texttt{nlink} がゼロより
も大きい限りは，その inode を解放しません．　

\texttt{iget()} で取得した \texttt{inode} 構造体を指すポインタは，対応す
る \texttt{iput} を呼ぶまでは有効です．すなわち，その inode は
削除されず，そのポインタが参照するメモリが別の inode のために
再利用されることはありません．\texttt{iget()} は，inode への非
排他的なアクセスを提供します．ファイルシステムの多くの部分が，こ
の \texttt{iget()} の動作に頼ることで，inode に対して（開いたファ
イルとカレントディレクトリとして）長期的な参照を持ったり，複数
の inode を操作するとき（たとえばパス名の解決）にデッドロック
を避けながら競合を防いだりします．

\texttt{iget} が返す \texttt{inode} 構造体は，意味ある中身を持っていな
いかもしれません．それが，ディスク上の inode のコピーであるこ
とを保証するには \indexcode{ilock} を呼ばなくてなりません．
すると，inode をロックし（他のプロセス
が \texttt{ilock} できないようにしてから），もしまだ読まれていなければ
ディスクから inode を読み出しま
す．\texttt{iunlock} は inode のロックを解放しま
す．inode へのポインタの取得とロックを分離することは，ある状況
においてデッドロックを避けるのに役立ちます．たとえば，ディレクトリを検
索しているときです．複数のプロセスが\texttt{iget} が返し
た inode へのポインタを持つ可能性がありますが，inode
をロックできるプロセスは 1 度に 1 つだけです．

カーネルのコードやデータ構造の C ポインタが指す inode のみが
キャッシュされます．その主な仕事は，実は複数プロセスからのアクセスを同
期化することにあり，キャッシュすること自体は副次的です．もしあ
る inode が頻繁に使われるならば，たとえ inode キャッシュ
に入っていなかったとしても，バッファキャッシュがメモリ上に置いておくは
ずだからです．inode キャッシュは\indextext{ライトスルー} (write through) です．
すなわち，キャッシュされた inode を書き換えたコードは，
\texttt{iupdate} を用いて即座にディスクへ書き込まなくてはなりません．

%% 
%%  -------------------------------------------
%% 
\section{Code: inode}

新しい inode をアロケートするとき（たとえばファイルを作ると
き），xv6 は \indexcode{ialloc} \lineref{kernel/fs.c:/^ialloc/} を呼びま
す．\texttt{ialloc} は \indexcode{balloc} とよく似ており，ディスク上
の inode 構造体を1ブロックずつスキャンし，未使用とマークされた
ものを探します．見つけたら，\texttt{ialloc} は新しい \texttt{type}をディ
スクに書き込むことでそれを確保し，最後に \indexcode{iget} を呼んで得
た inode キャッシュのエントリをリターンします \lineref{kernel/fs.c:/return.iget\(dev..inum\)/}．
\texttt{ialloc} が正しく動作するには，1度に1つの
プロセスだけが\texttt{bp} への参照を持つという事実が必要で
す．\texttt{ialloc} は，他のプロセスが同じ inode を同時に確保
しようとすることは無いと確信しています．

\texttt{iget} \lineref{kernel/fs.c:/^iget/} は inode キャッシュをスキャン
し，所与のデバイスと inode 番号を持つ使用中エント
リ (\texttt{(ip->ref > 0)}) を探します．見つけたら，そ
の inode への新しい参照をリターンします \linerefs{kernel/fs.c:/^....if.ip->ref.>.0/,/^....}/}．
\indexcode{iget} はスキャンするあいだ，
最初の空きスロットの場所を記録しておき，新しいキャッシュのエントリをアロケート
しなくてはならなくなったときに使います \linerefs{kernel/fs.c:/^....if.empty.==.0/,/empty.=.ip/}．

コードは，\indexcode{inode} のメタデータや中身を読み書きする前
に，\texttt{ilock} を用いてその inode をロックしま
す．\texttt{ilock} \lineref{kernel/fs.c:/^ilock/} はそのためにスリープロックを使いま
す．\indexcode{ilock} がその inode への排他的アクセスを取得したら，
必要に応じて inode をディスクから（多くの場合はバッファ
キャッシュから）読みます．\indexcode{iunlock} 関数
\lineref{kernel/fs.c:/^iunlock/}
はスリープロックを解放し，必要に応じて眠っていたプロセスを起床させます．

\texttt{iput} \lineref{kernel/fs.c:/^iput/} は，
参照カウントを減らすことで，あ
る inode への C ポインタを解放します \lineref{kernel/fs.c:/^..ip->ref--/}．
もしそれが最後の参照であれば，inode キャッシュにおけるそ
のinodeのスロットは未使用となり，別の inode のために
再利用できるようになります．

もしある inode を指す C ポインタが無く，またリンクも無い
（どのディレクトリにも入っていなかったら）ことに \indexcode{iput} が気づいた
ら，inode とそのデータブロックを解放しなくてはなりませ
ん．\texttt{iput} は \indexcode{itrunc} を呼び出してファイルを 0 バイトに
トランケートすることで，データブロックを解放します．また，
inode の \texttt{type} を 0 (未使用)にセットし，
それをディスクに書き込みます \lineref{kernel/fs.c:/inode.has.no.links.and/}.

\indexcode{iput} が inode を解放するときのロックのプロトロルは詳
しく見る価値があります．危険かもしれないのは，その inode を使
うために（たとえばファイルやディレクトリの一覧を見るため
に）\texttt{ilock} で待っている別のスレッドがいるかもしれないことです．
そのスレッドは，inode が解放されてしまうことを想定してい
ません．しかしそのようなことは決して起きません．リンクが無く，か
つ \texttt{ip->ref} が 1 であるならば，システムコールは，そのキャッシュ
された inode へのポインタを得ることはできないはずだからです．
なお，その 1 つの参照は，\texttt{iput} を呼んだスレッドによるもので
す．\texttt{iput} は，\texttt{icache.lock} クリティカルセクションの外で
参照カウントが 1 であることを確認しますが，その時点においてリンク数
は 0 であることがわかっているので，他のスレッドが新しいリファレンスを取
得しようとすることはありません．
%
他にありうるかもしれない危険は，並行する \texttt{ialloc} の呼び出し
が，\texttt{iput} が解放しようとしているのと同じinode を選んで
しまうことです．それが生じるとしたら，inode の \texttt{type}
が 0 になるように\texttt{iupdate} がディスクに書き込んだあとです．この
競合は良性です．アロケートしようとしているスレッド
は，inode に読み書きを行うまえに，inode のスリープロッ
クをおとなしく待ちます．それまでには，\texttt{iput} は仕事を終えています．

\texttt{iput()} はディスクへの書き込みを行うことがあります．す
なわち，ファイルシステムを使うシステムコールはどんなものでもディスクへ
の書き込みを行うことがあるということです．なぜなら，そのシステムコール
が持つ参照が，そのファイルへの最後の参照かもしれないからで
す．\texttt{read()} は読み込みしかしないように見えます
が，最終的に \texttt{iput()} を呼ぶことがありえます．よって，ファ
イルシステムを使うならば，たとえ読み込みしか行わないシステムコールであっ
ても，トランザクションでくるむ必要があります．

\texttt{iput()} とクラッシュには難しい関係がありま
す．\texttt{iput()} は，そのファイルへのリンク数がゼロになったとき，す
ぐにトランケートするわけではありません．他のプロセスが，そのメモ
リ上 inode への参照を持っているかもしれないからです．まだその
ファイルへの読み書きをしているプロセスもあるかもしれません．一方，全て
のプロセスがそのファイルへのファイルディスクリプタを閉じる前にクラッシュ
が起きたら，そのファイルはディスク上で使用中にもかかわらず，それを指す
ディレクトリエントリが全くないという状況になってしまいます．

ファイルシステムがその問題を処理する方法は 2 通りあります．簡単な解決法
は，再起動後の復帰時に，ファイルシステム全体をスキャンして，そのような
（使用中だがそれを指すディレクトリエントリが無い）ファイルを探すという
ものです．もしそのようなファイルを見つけたら解放します．

2 つ目の解決法は，ファイルシステムをスキャンしなくても良い方法です．そ
の解決法は，リンク数がゼロになったが，参照カウントがゼロになっていな
いinode の i-number を，ディスク上に
（たとえばスーパーブロックに）記録しておくというものです．もし，参照カ
ウントがゼロになってそのファイルを削除したら，ファイルシステム
はinode をそのディスク上のリストから削除します．復帰時には，そ
のリストに載っているファイルを解放します．

xv6 は，どちらの解放も実装しません．すなわち，ディスク上で使用中に
なっているにもかかわらず，もう使われていないものがあるかもしれないとい
うことです．それにより，xv6 には，時間が経つとともにディスクのスペースを使
い切ってしまうというリスクがあります．
%% 
%% 
%% 
\section{Code: inode の中身}

\begin{figure}[t]
\center
\includegraphics[scale=0.5]{fig/inode.pdf}
 \caption{ディスク上でのファイルの表現} 
\label{fig:inode}
\end{figure}


ディスク上の inode である \texttt{dinode} 構造体は，サイズとブロック番
号の配列を持ちます（図~\ref{fig:inode} を見てください）．その inodeのデー
タは，\texttt{addrs} 配列が指すブロックに入っています．データの先
頭 \indexcode{NDIRECT} ブロックは，その配列の先頭 \texttt{NDIRECT} 要素
に入っています．それらは，直接ブロック (direct block) と呼ばれます．次
の \indexcode{NINDIRECT} ブロックは，inode そのものではなく，間接ブロッ
ク (indirect block)と呼ばれるデータブロックに入っていま
す．\texttt{addrs} の最後のエントリには，\indextext{間接ブロック}のアド
レスが入っています．よって，ファイルの先頭 12 kB
(\texttt{NDIRECT}$\times$\indexcode{BSIZE}) は inode 内のリストからロー
ドすることができ，その次の 256 kB
(\texttt{NINDIRECT}$\times$\texttt{BSIZE})は，間接ブロックを調べたあと
でロードする必要があります．これは，ディスク上の表現としては優れていま
すが，利用者にとっては複雑です．\indexcode{bmap} という関数が，すぐあと
に出てくる \indexcode{readi} や \indexcode{writei} などの高レベルのルー
チンのために，その表現を管理をします．\texttt{bmap} は，inode を表
す \texttt{ip} に対し，\texttt{bn} 番目のデータブロックのブロック番号を
リターンします．もし \texttt{ip} がまだそのブロックを持たなけれ
ば，\texttt{bmap} がアロケートします．

\indexcode{bmap}~関数 \lineref{kernel/fs.c:/^bmap/} は
簡単なケースからはじめます．すな
わち，inode 自体に記録されている最初の \indexcode{NDIRECT} ブロッ
クです \linerefs{kernel/fs.c:/^..if.bn.<.NDIRECT/,/^..}/}．次の \indexcode{NINDIRECT} ブロック
は，\texttt{ip->addrs[NDIRECT]} の間接ブロックにありま
す．\texttt{bmap} は間接ブロックを読み \lineref{kernel/fs.c:/bp.=.bread.ip->dev..addr/}，
ブロック内の右側からブロック番号を読みます \lineref{kernel/fs.c:/a.=..uint\*.bp->data/}．
もしブロック番号が \texttt{NDIRECT+NINDIRECT} を超えたら
\texttt{bmap} はパニックを起こします．\texttt{writei} には，
それを防ぐためのチェックがあります \lineref{kernel/fs.c:/off...n...MAXFILE.BSIZE/}.

\texttt{bmap} は必要に応じてブロックをアロケートしま
す．\texttt{ip->addrs[]} もしくは間接エントリがゼロであることが，ブロッ
クがアロケートされていないことを示します．\texttt{bmap} はゼロ
を，\texttt{demand} \linerefs{kernel/fs.c:/^....if..addr.=.*==.0/,/./}
\linerefs{kernel/fs.c:/^....if..addr.*NDIRECT.*==.0/,/./} を用いて
新しくアロケートしたブロックの番号に置き換えます．

\indexcode{itrunc} はファイルが含むブロックの解放を行い，
その inode のサイズをゼロに戻します．
\texttt{itrunc} \lineref{kernel/fs.c:/^itrunc/} は
まず直接ブロックを解放し \linerefs{kernel/fs.c:/^..for.i.=.0.*NDIRECT/,/^..}/}，
続いて間接ブロックに記載されたブロックを解放し \linerefs{kernel/fs.c:/^....for.j.=.0.*NINDIRECT/,/^....}/}，
最後に間接ブロック自体を解放します　\linerefs{kernel/fs.c:/^....bfree.*NDIRECT/,/./}．

\texttt{bmap} のおかげで，\indexcode{readi} と \indexcode{writei} は簡単
に inodeのデータを取得できます．
\texttt{readi} \lineref{kernel/fs.c:/^readi/} はまず，
オフセットとカウント数がファイルの終端を超え
ないことを確認します．終端の先を開始点とする読み込みにはエラーをリター
ンします \linerefs{kernel/fs.c:/^..if.off.>.ip->size/,/./}．
一方，終端をまたぐ読み込みに対しては，
要求よりも少ないバイト数をリターンします \linerefs{kernel/fs.c:/^..if.off.>.ip->size/,/./}．
メイン
ループはファイルの各ブロックをスキャンし，バッファの各データ
を \texttt{dst} へコピーします \linerefs{kernel/fs.c:/^..for.tot=0/,/^..}/}．
\indexcode{writei} \lineref{kernel/fs.c:/^writei/} は \indexcode{readi} と同じですが，3つ例外があります．終
端をまたぐ書き込みでは（最大サイズになるまでは）ファイルサイズを拡張しま
す \linerefs{kernel/fs.c:/^..if.off.\+.n.>.MAXFILE/,/./}．
ループでは，\texttt{out} ではなくバッファにデー
タをコピーします \lineref{kernel/fs.c:/memmove.*bp->data/}．もし書き込みがファイルを拡張した
ら，\indexcode{writei} はそのサイズを更新します \linerefs{kernel/fs.c:/^..if.n.>.0./,/^..}/}．

\indexcode{readi} と \indexcode{writei} は，まず \texttt{ip->type ==} \indexcode{T_DEV}
のチェックをします．これは，データがファイルシステム内には無い特殊ファイルの場合です．
このケースについては，ファイルディスクリプタ層のところでまた
説明します．

\indexcode{starti}~関数 \lineref{kernel/fs.c:/^stati\(/} は
inode のメタデータ
を\texttt{stat} 構造体へコピーします．ユーザプログラム
は \indexcode{stat} システムコールを呼ぶことで，この構造体を見ることがで
きます．

%% 
%% 
%% 
\section{Code: ディレクトリ層}

ディレクトリは，内部的にはほとんどファイルです．ディレクトリ
の inode は \indexcode{T_DIR} というタイプを持ち，その
中身はディレクトリエントリが並んだものです．各エントリ
は \indexcode{dirent} 構造体 \lineref{kernel/fs.h:/^struct.dirent/} で，名前
と inode 番号を含みます．名前は最大で \indexcode{DIRSIZ} (14) 文
字までです．それより短い場合はNUL (0) で終端します．inode 番号
がゼロのディレクトリは未使用です．

\indexcode{dirlookup}~関数 \lineref{kernel/fs.c:/^dirlookup/} は，指定された名前のファイル
をディレクトリから探します．見つかったら，対応する（ロックされてい
ない） inode へのポインタを返します．また，呼び出し側が編集す
ることに備えて，\texttt{*poff} に，そのディレクトリ内のエントリへのバイ
トオフセットをセットします．\texttt{dirlookup} が正しい名前のエントリを
見つけたら，\texttt{*poff} を更新して，\indexcode{iget} で得たロックされて
いない inode をリターンしま
す．\texttt{iget} が inode をロックしないの
は \texttt{dirlookup} のためです．呼び出し元がロックした \texttt{dp}
を持っているので，もし探す対象がカレントディレクトリの別名である (\indexcode{.}) で
あった場合，リターンする前に inode をロックしようとする
と \texttt{dp} をさらにロックしようとしてデッドロックします（マルチプロ
セスと親ディレクトリ（\indexcode{..}）に関連して，より入り組んだデッドロックのシナ
リオがあります．カレントディレクトリだけが問題なのではありません）．
呼び出し元は \texttt{dp} をアンロックしてから \texttt{ip} をロック
することで，1 度に 1 つのロックしか取得しないことを保証できます．

\indexcode{dirlink}~関数 \lineref{kernel/fs.c:/^dirlink/} は，ディレクトリ \texttt{dp} に
対し，名前と与えられた inode 番号を持つ新しいディレクトリエン
トリを作ります．もしその名前がすでに存在したら，\texttt{dirlink} はエラーをリ
ターンします \linerefs{kernel/fs.c:/Check.that.name.is.not.present/,/^..}/}．
メインループはディレクトリエントリを
スキャンして，未使用のエントリを探します．もし見つけたら，
\texttt{off} にそのエントリのオフセットを記入してループを抜けます \linerefs{kernel/fs.c:/^....if.de.inum.==.0/,/./}．
そうでない場合は，\texttt{off} に \texttt{dp->size} をセットして
ループを終えます．いずれの場合でも，\texttt{dirlink} は \texttt{off} が指す場所に
新しいエントリを付け足します \linerefs{kernel/fs.c:/^..strncpy/,/panic/}．

%% 
%% 
%% 
\section{Code: パス名}

パス名を探索するには，パスの各項目に対して何度も \indexcode{dirlookup} を呼ぶ必要があります．
\texttt{namei} \lineref{kernel/fs.c:/^namei/} はパスを評価し，
対応する inode をリターンします．\indexcode{nameiparent}~関数はその
派生版で，最後の要素の一歩前で止め，親ディレクトリの inode をリターン
するとともに，最後の要素を \texttt{name} に入れます．どちらの場合でも，より
一般的な \indexcode{namex} 関数が実際の処理を行います．

\texttt{namex} \lineref{kernel/fs.c:/^namex/} はまず，
パス評価の起点を決めます．もし
パスの先頭がスラッシュなら，評価はルートディレクトリから始めます．そう
でない場合はカレントディレクトリで
す \linerefs{kernel/fs.c:/..if.\*path.==....\)/,/idup/}．
\texttt{namex} は次に，\indexcode{skipelem} を用
いて，パスの各要素を順に調べていきます \lineref{kernel/fs.c:/while.*skipelem/}．
ループの各く
り返しでは，今調べている inode であ
る \texttt{ip} から \texttt{name} を探します．探すにはまず \texttt{ip}
をロックし，それがディレクトリかどうかを調べます．そうでなければ探索失
敗です \linerefs{kernel/fs.c:/^....ilock.ip/,/^....}/}（\texttt{ip} をロックする必要があるの
は，\texttt{ip->type} を変更するからではありません（変更できません
）．\indexcode{ilock} が走るまで，\texttt{ip->type} がディスクからロードさ
れているとは限らないからです）．もしそれが \indexcode{nameiparent} で
パスの最後の要素であれば，\texttt{nameiparent} の定義の通り，そこでルー
プを抜けます．最後の要素はすでに \texttt{name} にコピーされているの
で，\indexcode{namex} は単にロックを解除した\texttt{ip} 
\linerefs{kernel/fs.c:/^....if.nameiparent/,/^....}/} を返します．そのループは最後に，その要素
を \indexcode{dirlookup} で探し，\texttt{ip = next} 
\linerefs{kernel/fs.c:/^....if..next.*dirlookup/,/^....ip.=.next/} 
とすることで次のくり返しの準備をします．ループがパス名の最後までいった
ら，\texttt{namex} は \texttt{ip} をリターンします．

\texttt{namex} には長い時間がかかることがあります．パス名を解
決するために訪れる複数のディレクトリに対し，inode とディレクリ
ブロックを取得するために，（バッファキャッシュに入っていない場合）何度
もディスクのオペレーションを行う必要があるからです．xv6 は注意深く設計され
ており，もし，あるカーネルスレッドの \texttt{namex} がディスク I/O でブ
ロックしていたら，別のパス名を探している別のカーネルスレッドが並行して
進むことができます．\texttt{namex} はパス上にあるディレクトリを別々にロッ
クするので，別ディレクトリの探索は並行して行うことができるのです．

そのような並列処理ができることで，いくつかの新たな課題が生じます．た
とえば，あるカーネルスレッドがパス名を探索しているあいだ，別のカーネル
スレッドがあるディレクトリをアンリンクすることで，ディレクトリツリーが
変わってしまうことがありえます．それにより，すでに消去されたディレクト
リを探してしまう潜在的な危険性があります．その消去されたディレクトリの
ブロックは，別にディレクトリやファイルに再利用されている可能性がありま
す．

xv6 ではそのような競合は起きません．たとえ
ば，\texttt{namex} が \texttt{dirlookup} を実行しているあいだ，探索をし
ているスレッドはそのディレクトリのロックを所持するととも
に，\texttt{dirlookup} は \texttt{iget} で取得した inode をリ
ターンします．\texttt{iget} は，inode の参照カウントを増加させ
ます．\texttt{namex} がそのディレクトリのロックを解放するの
は，\texttt{dirlookup} から inode を受け取ったあとに限ります．
別スレッドがその inode をディレクトリからアンリンクする可能性
がありますが，その inode の参照カウントはゼロより大きいの
で，xv6 がその inode を削除することはありません．

別のリスクはデッドロックです．たとえば，「\texttt{.}」を探索すると
き，\texttt{next} は \texttt{ip} と同じ inode を指す可能性があ
ります．\texttt{ip} のロックを解放する前に \texttt{next} をロックしよう
とするとデッドロックが起きます．このデッドロックを避けるため
に，\texttt{namex} は \texttt{next} のロックの取得前にそのディレクト
リをアンロックします．それもまた，\texttt{iget} と \texttt{ilock} を分
けておく重要な理由です．

%% 
%% 
%% 
\section{ファイルディスクリプタ層}

Unix のインタフェースのかっこいいところは，ほぼ全てのリソースがファイル
として表現されるところです．コンソールなどのデバイス，パイプ，そし
てもちろん本物のファイルなどです．その一貫性をもたらすのがファイルディ
スクリプタ層です．

\ref{CH:UNIX}~章で見たように，xv6 は，プロセスごとに開いたファイルのテーブル，すなわ
ちファイルディスクリプタを与えます．開いたファイルは，それぞ
れ \indexcode{file} \lineref{kernel/file.h:/^struct.file/} で表現されます．この構造体
は，inode もしくはパイプをくるんで I/O オフセットを付け加えた
ものです．\indexcode{open} を呼びだすと，そのたびに開いたファイル（新し
い \texttt{file} 構造体）が作られます．複数のプロセスが独立に同じファイ
ルを \texttt{open} すると，それぞれが異なる I/O オフセットを持ちます．
一方，同一の開いたファイル（すなわち同一の \texttt{file} 構造体）は，あ
る1つのプロセスのファイルテーブルに複数回現れたり，複数のプロセスに現れ
ることができます．そのようなことが起きるのは，あるプロセス
が \texttt{open} を用いてファイルを開いたあとで\indexcode{dup} で別名を作っ
たり，\indexcode{fork} で子プロセスを作って共有したりした場合です．参照カ
ウントが，特定の開いたファイルへの参照数を管理します．ファイルは，読み，
書き，あるは両方のために開くことができます．それ
は \texttt{readable} と \texttt{writable} フィールドが管理します．

システム内のオープン済みファイルは，グローバルファイルテーブ
ル\indexcode{ftable} に入ります．このファイルテーブルはファイルをアロケート
するための関数 (\indexcode{filealloc})，参照を作ったり複製する関
数 (\indexcode{filedup})，参照を解放するための関数 (\indexcode{fileclose})，
および読み書きするための関数 (\indexcode{fileread} と \indexcode{filewrite})
があります．

先の3つは，今や見慣れたかたちをしています．\texttt{filealloc}
\lineref{kernel/file.c:/^filealloc/} はファイルテーブルをスキャンして参照のないファイ
ル\texttt{(f->ref == 0)} を探し，新しい参照をリターンしま
す．\indexcode{filedup} \lineref{kernel/file.c:/^filedup/} は
参照カウントを増加さ
せ，\indexcode{fileclose} \lineref{kernel/file.c:/^fileclose/} は
減少させます．ファイルの参
照カウントがゼロに達したら，\texttt{fileclose} は\texttt{type} に応じて
パイプもしくは inode を解放します．

\indexcode{filestat}, \indexcode{fileread} および \indexcode{filewrite} 関数が，
ファイルへの \indexcode{stat}, \indexcode{read}, およ
び \indexcode{write} の処理をそれぞれ実装します．\texttt{filestat}
\lineref{kernel/file.c:/^filestat/} は inode に対してのみ使用可能
で，\indexcode{starti} を呼び出します．\texttt{fileread} と \texttt{filewrite} は，そ
の処理が \texttt{open} 時のモードによって許可されているかどうかをチェッ
クし，パイプあるいは inode 用の実装につなぎます．
もしファイルが inode を表すのであれ
ば，\texttt{fileread} と \texttt{filewrite} は I/O オフセットをその処理
のオフセットとして用い，そのあとに増加させます \linerefs{kernel/file.c:/readi/,/./}
\linerefs{kernel/file.c:/writei/,/./}．
パイプにはオフセットという概念はありません．inode の関数では，
呼び出し元がロックを管理しなくてはいけないのでし
た \linerefs{kernel/file.c:/stati/-1,/iunlock/}
\linerefs{kernel/file.c:/readi/-1,/iunlock/}
\linerefs{kernel/file.c:/writei\(f/-1,/iunlock/}．
inode のロックには便利な副作用があ
り，読み書きのオフセットが自動で更新されます．
そのため，同一ファイルへの同時書きこみがお互いを上書きすることはありません．
ただし，両者は混ざってしまいます．

%% 
%% 
%% 
\section{Code: システムコール}

低レイヤが提供する関数のおかげで，ほとんどシステムコールの実装は単純です
（\fileref{kernel/sysfile.c} を見てください）．ただし，いくつかのシステムコールは
よく見る価値があります．

\indexcode{sys_link} 関数と \indexcode{sys_unlink} 関数はディレクトリを編集
することで，inode への参照を作ったり削除したりします．これも，
トランザクションの威力が分かる良い例です．\texttt{sys\_link}
\lineref{kernel/sysfile.c:/^sys_link/} はまず，2つ引数である文字
列 \texttt{old} と \texttt{new} を取得します \lineref{kernel/sysfile.c:/argstr.*old.*new/}．
\texttt{old} は存在して，かつディレクトリでは無いものとしま
す \linerefs{kernel/sysfile.c:/namei.old/,/^..}/}．\texttt{sys\_link} は\texttt{ip->nlink}の
カウント値を増加させます．\texttt{sys\_link} は続い
て \indexcode{nameiparent} を呼び，\texttt{new} の親ディレクトリとパスの最
後の要素を得ます \lineref{kernel/sysfile.c:/nameiparent.new/}．そのあ
と，\texttt{old} の inode を指す新しいディレクトリエントリを作
ります \lineref{kernel/sysfile.c:/\|\| dirlink/}．新しい親ディレクトリは存在しなくてはな
らず，かつ既存の inode と同じデバイス上になくてはなりませ
ん．inode 番号は，同一のデバイス上においてのみユニークだからで
す．そのようなエラーが起きたら, \indexcode{sys_link} は逆戻りし
て\texttt{ip->nlink} を減少させます．

複数ブロックにまたがる更新をするときに，その実行順序を気にしなくてよく
なるという意味で，トランザクションは実装を単純にします．トランザクショ
ンは，全部が成功するか，まったく成功しないかのいずれかです．もしトラン
ザクションがなければ，リンクを作るまえに\texttt{ip->nlink} を更新すると，
ファイルシステムは一時的に安全ではない状態になります．その間にクラッシュ
が起きたら大惨事です．そのことを気にしなくてもよいのは，トランザクショ
ンがあるからです．

\texttt{sys\_link} は，既存の inode に新しい名前をつけま
す．\indexcode{create} 関数 \lineref{kernel/sysfile.c:/^create/} は，新し
い inode に新しい名前をつけます．これは，ファイルを作る 3 つの
システムコールを一般化したものです．すなわち，新しい通常ファイルを作
る \indexcode{O_CREATE} フラグ付きの \texttt{open}, 新しいディレクトリを
作る \indexcode{mkdir}，および新しいデバイスファイルを作る \indexcode{mkdev}
です．\indexcode{sys_link} と同様に，\indexcode{create} はま
ず \texttt{nameiparent} を呼び，親ディレクトリの inode を得ま
す．\texttt{create} は続いて \indexcode{dirlookup} を呼び，その名前がすで
に存在するかどうかをチェックします \lineref{kernel/sysfile.c:/dirlookup.*[^=]=.0/}．もし存在した
ときの処理は，\texttt{create} を呼び出したシステムコールによりま
す．\indexcode{open} は，\indexcode{mkdir}・\indexcode{mkdev} とは異なる意味
を持ちます．もしその \texttt{create} が \texttt{open} のために呼び出さ
れたものであり (\texttt{type ==} \indexcode{T_FILE})，かつ既存のファイルが通常のファ
イルであれば，\texttt{open} はこれを成功とみなすので，\texttt{create}も
同様にします \lineref{kernel/sysfile.c:/^......return.ip/}．それ以外では，重複するファイル名は
エラーです \linerefs{kernel/sysfile.c:/^......return.ip/+1,/return.0/}. もしその名前が使用済みでなけれ
ば，\texttt{create} は \indexcode{ialloc} \lineref{kernel/sysfile.c:/ialloc/} を用いて新しい inode をアロケート
します．もし新しい inode がディレクトリであれ
ば，\indexcode{.} と \indexcode{..} のエントリで初期化します．ここまででデー
タが正しく初期化されたので，\indexcode{create} はそれを親ディレクトリにリ
ンクします \lineref{kernel/sysfile.c:/if.dirlink/}．\texttt{create} は，\indexcode{sys_link} と同様
に，2 つの inode のロック \texttt{ip} と \texttt{dp} を同時に取得します
が，デッドロックの危険はありません．\texttt{ip} は今まさに取得したもの
であるため，他のプロセスが \texttt{ip} のロックを取得した上
で \texttt{dp} をロックしようとすることはありえないからです．

\texttt{create} を使うと，\indexcode{sys_open}, \indexcode{sys_mkdir}, およ
び \indexcode{sys_mknod} は簡単に実装できます．\texttt{sys\_open}
\lineref{kernel/sysfile.c:/^sys_open/} がもっとも複雑なのは，ファイルを作る以外の仕事
もするからです．\indexcode{O_CREATE} フラグ付きで \indexcode{open} が呼
び出されると，\texttt{open} は \texttt{create} を呼び出しま
す \lineref{kernel/sysfile.c:/create.*T_FILE/}．そうでない場合，
\texttt{open} は \indexcode{namei} を呼びま
す \lineref{kernel/sysfile.c:/if..ip.=.namei.path/}．\texttt{create} はロックされ
た inodeをリターンしますが，\texttt{namei} はそうではありませ
ん．そのため，inode 自体のロックは \texttt{sys\_open} が行わな
くてはなりません．\indexcode{sys_open} は，ディレクトリが書き込みでなく読み込み用に開か
れることチェックする良い場所です．inode を何らかの方法で得た
ら，\texttt{sys\_open} はファイルおよびファイルディスクリプタをアロケー
トし \lineref{kernel/sysfile.c:/filealloc.*fdalloc/}，ファイルの中身を書き込みま
す \linerefs{kernel/sysfile.c:/type.=.FD_INODE/,/writable/}．なお，初期化途中のファ
イルは現在のプロセスのテーブルにしか入っていないので，他のプロセ
スがアクセスすることはありえません．


\ref{CH:SCHED}~章では，ファイルシステムに知る前にパイプの実装を見まし
た．\indexcode{sys_pipe} 関数は，パイプのペアをつくることで，その実装とファ
イルシステムをつなげます．引数は整数 2 つ分の領域へのポインタです．
\texttt{sys\_pipe} 関数はパイプをアロケートし，ファイルディスクリ
プタを引数の領域に書き込みます．

%% 
%%  -------------------------------------------
%% 
\section{世の中のオペレーティングシステム}

世の中のオペレーティングシステムのバッファキャッシュは，xv6 のものより
もはるかに複雑です．しかし目的は同じで，ディスクアクセスをキャッ
シュすることと同期化することです．xv6 のバッファキャッシュは V6 
と同じで，単純な LRU 
の立ち退きポリシーを採用しています．より複雑なポリシーがたくさんありえ，
ある種の負荷に特化した性能を持ちます．より効率的な LRU キャッシュは，最
も使われていないものを探し，かつヒープを維持するために，リンクリストで
はなくハッシュテーブルを使います．現代的なバッファキャッシュは，メモリ
にマップされたファイルをサポートするために，仮想メモリシステムと統合さ
れています．

xv6 のロギングシステムは非効率です．まず，ファイルシステム系のシステム
コールと並行してコミットを行うことができません．また，あるブロックにお
ける変更が数バイトしか無い場合でも，システムはブロック全体のログをとり
ます．1 ブロックずつ同期的にログ書き込みを行いますので，それぞれ
ごとに，ディスク 1 周分の時間がかかる可能性があります．世の中のロギング
システムは以上の問題を解決しています．

ロギングだけがクラッシュリカバリの方法ではありません．初期のファイルシス
テムは，再起動時にスカベンジング（ゴミ漁り，たとえ
ば，Unix の \indexcode{fsck}）をして，全ファイル・ディレクトリ・ブロッ
ク・inode の自由リストを調べ，一貫性がない部分を解決していまし
た．大きいファイルシステムでは，スカベンジングには何時間もかかり，かつ
一貫性のない箇所を（システムコールがアトミックであるかのようには）修
正できない場合がありました．ログを用いた復帰ははるかに速く，クラッシュ時
にシステムコールをアトミックにできます．

xv6 は，inode とディレクトリを配置するのに，初期の Unix と同様
の基本的なディスク上のレイアウトを用います．この方法は何年ものあいだ，
驚くほど維持されてきました．BSD の UFS/FFS および Linux の ext2/ext3 も，
本質的には同じデータ構造を持ちます．ファイルシステムのレイアウトにおい
てもっとも非効率な部分はディレクトリです．各探索において，全てのディスクブ
ロックを線形にスキャンしなくてはならないからです．ディレクトリ
が数ブロックしかないときはリーズナブルですが，大量のファイルを持つディ
レクトリでは高コストになりえます．少なくと
も，Microsoft Windows の NTFS，Mac OS X の HFS，そして Solaris の ZFSな
どは，ディスク上のバランスしたブロックのツリーとしてディレクトリを実装
します．これは複雑な方法ですが，ディレクトリ探索が対数時間で終わること
を保証してくれます．

xv6 はディスクのフェイルに対してナイーブです．もしディスクのオペレーションが
フェイルしたら xv6 はパニックになります．これがリーズナブルかどうかはハード
ウェアによります．もし，オペレーティングシステムが乗っているのが，ディ
スクのフェイルを吸収できる冗長性を備えた特別なハードウェアであれば，オペレー
ティングシステムがフェイルに出会うのは稀なので，パニックになっても大丈夫でしょ
う．一方で，通常のディスクを使うオペレーティングシステムは，フェイルを見越
してより穏やかな方法で処理し，ファイルの1ブロックの欠けがシステ
ム全体に波及しないようにすべきです．

xv6 は，ファイルシステムが単一のディスクデバイスに収まっており，かつサ
イズが変わらないと想定します．大きなデータベースやマルチメディアにおける
大容量化への要求は増すばかりなので，オペレーティングシステムは「1ディス
ク1ファイルシステム」というボトルネックを解消するように発展しています．
基本的なアプローチは，複数のディスクを組み合わせて単一の論理的なディス
クにすることです．RAID などのハードウェア的な方法が現在でも一般的ですが，
そのための機能をできるだけソフトウェアで実現する方向にトレンドは向かっ
ています．そのようなソフトウェア実装は，通常，ディスクをその場で足した
り減らしたりすることで，論理的なデバイスを大きくしたり小さくしたりする
リッチな機能を持ちます．ストレージ層がその場で大きくなったり
小さくなったりするのであれば，ファイルシステムも同じことができなくては
なりません．固定長配列に inode ブロックを入れる xv6 の方法は，
そのような環境では使うことができません．ディスクの管理とファイルシステ
ムを分離することがもっともクリアな設計ですが，それらのインタフェースが複雑
なので，Sun の ZFS のように両者を組み合わせることもあります．

xv6 のファイルシステムは，現代的なファイルシステムにはあるたくさんの機
能が欠けています．たとえば，スナップショットの作成や，インクリメンタル
なバックアップをすることがでません．

現代的な Unix システムでは，ディスク上のストレージと同じシステムコール
を用いて，さまざまな種類のリソースにアクセスすることができます．名
前付きパイプ，ネットワーク接続，遠隔からアクセスするネットワークファイ
ルシステム，および \texttt{/proc} のような監視・制御用のインタフェース
です．xv6 では， \indexcode{fileread} や \indexcode{filewrite} の中
の\texttt{if} 文で条件分岐をしています．それに対して，現代的なシステムでは，開い
たファイルごとにオペレーションに対応する関数ポインタのテー
ブルを与えることで，inode ごとに特有の実装を呼び出せるようになっ
ています．ネットワークファイルシステムとユーザレベルファイルシステムが
提供する関数には，それらの呼び出しをネットワークごしの RPC (remote
procedure call) に変換し，レスポンスが得られるまで待つ機能があります．

%% 
%%  -------------------------------------------
%% 
\section{練習問題}

\begin{enumerate}

\item \texttt{balloc} がパニックを起こす可能性があるのはなぜでしょうか？xv6 はそこから復帰できるでしょうか？

\item \texttt{ialloc} がパニックを起こす可能性があるのはなぜでしょうか？xv6 はそこから復帰できるでしょうか？

\item ファイルを使い切ったときに \texttt{filealloc} がパニックを起こさ
  ないのはなぜでしょうか？それがより一般的で，かつ処理する価値があるの
  はなぜでしょうか？

\item \texttt{sys\_link} におい
  て，\texttt{iunlock(ip)} と \texttt{dirlink}の間で，\texttt{ip} に対
  応するファイルが別プロセスによってアンリンクされたとします．
  リンクは正しく作られるでしょうか？それはなぜでしょうか？

\item \texttt{create} は進むために必要な関数呼び出しを 4 回行います (そ
  のうち 1 つは \texttt{ialloc} で，残り 3 つは \texttt{dirlink})．どれ
  か 1 つでも欠ければ \texttt{create} は \texttt{panic} を呼びます．そ
  れでも良いのはなぜでしょうか？これらの 4 つの関数コールがどれも失敗し
  ないのはなぜでしょうか？

\item \texttt{sys\_chdir} は，\texttt{p->cwd} をロックするかもしれな
  い\texttt{iput(cp->cwd)}の前に，\texttt{iunlock(ip)} を呼びます．しか
  し，\texttt{iunlock(ip)} を \texttt{iput} のあとまで延期してもデッド
  ロックは起きません．それはなぜでしょうか？

\item \texttt{lseek} システムコールを実装してください．
  \texttt{lseek} をサポートするには，\texttt{filewrite} も改造する必要があります．
  \texttt{lseek} が \texttt{f->ip->size} を超えた場合，ファイルのその領域をゼロで
  埋める必要があるためです．

\item \texttt{open} に，\texttt{O\_TRUNC} と \texttt{O\_APPEND} を追加
  して，シェルで \texttt{>} および \texttt{>>} オペレータが動くようにし
  てください．

\item ファイルシステムを改造して，シンボリックリンクをサポートしてください．

\item ファイルシステムを改造して，名前付きパイプをサポートしてください．

\item ファイルシステムと仮想メモリシステムを改造して，\texttt{mmap} をサポートしてください．

\end{enumerate}
