\chapter{オペレーティングシステムのインタフェース}
\label{CH:UNIX}


オペレーティングシステムの役割は，複数のプログラムで 1 台のコンピュータ
を共有することと，ハードウェア単独よりも便利なサービスを提供することに
あります．オペレーティングシステムは下層にあるハードウェアを管理・抽象
化します．そうすることで，たとえば，ワードプロセッサがディスクハードウェ
アの種類を気にしなくてよくなります．また，複数のプログラムでハードウェ
アを共有することで，それらを同時に実行することができます．また，プログ
ラム同士がデータを共有したり一緒に働いたりするため
の，管理された方法を提供します．

オペレーティングシステムは，あるインタフェースを介して，ユーザープログ
ラムにサービスを提供します．
\index{interface design}
良いインタフェースを設計するのは難しいこと
が分かっています．単純かつ限定的なインタフェースは実装のしやすさで優れて
いますが，洗練されたたくさんの機能を提供したいという誘惑もあります．両
立するためのトリックは，少数のメカニズムにしか依存しないインタフェース
を設計し，それらの組み合わせにより多様性を実現することです．


この本は，オペレーティングシステムの概念を学ぶための実例として，あるオ
ペレーティングシステムを用います．それは xv6 と言い，Ken
Thompson と Dennis Ritchie による Unix オペレーティングシステム~\cite{unix} の基本的
なインタフェースを提供するとともに，Unix の内部設計を模倣していま
す．Unix は限定されたインタフェースを提供しますが，それらは巧みに組み合
わせることができ，驚くほどの多様さを実現することができます．このインタ
フェースは大成功しており，現代的なオペレーティングシステムであるBSD,
Linux, Mac OS X, Solaris, また程度の差はありますが Microsoft Windows ま
でもが Unix 的なインタフェースを持っています．xv6 を理解することは，そ
のようなオペレーティングシステムを理解するよいスタート地点になるはずで
す．

図~\ref{fig:os} に示すように，xv6 は古典的な\indextext{カーネル}，すなわち実行
中のプログラムにサービスを提供する特殊なプログラムのかたちをとります．
実行中の各プログラム（\indextext{プロセス}と呼びます）は命令列を含むメモリ，データ，
およびスタックを持ちます．命令列は，プログラムの計算を実現します．デー
タは，計算が対象とする変数のことです．スタックはプログラムのプロシージャ
呼び出し (procedure call) を管理します．


プロセスがカーネルのサービスを呼び出すときは，オペレーティングシステムの
インタフェースを介してプロシージャ呼び出しを行います．
そのようなプロシージャは\indextext{システムコール}と呼ばれます．システムコールはカー
ネルに入り，サービスを実行してリターンします．すなわちプロセスは，
\indextext{ユーザ空間}と\indextext{カーネル空間}を行ったり来たりします．


カーネルは，CPU が提供するハードウェア的な保護メカニズムを利用して，ユー
ザ空間で実行する各プロセスが，固有のメモリにしかアクセスできないように
します．そのような保護を実現するには，ハードウェア的な特権を持つカーネ
ルが必要です．ユーザプログラムにはそのような特権がありません．ユーザプ
ログラムがシステムコールを発行すると，ハードウェアが特権レベルを昇格さ
せ，あらかじめ設定しておいたカーネルの関数を実行します．


\begin{figure}[t]
\center
\includegraphics[scale=0.5]{fig/os.pdf}
\caption{カーネルと 2 つのユーザプロセス}
\label{fig:os}
\end{figure}


カーネルが提供するシステムコールが，ユーザプログラムから見えるインタ
フェースです．xv6 カーネルは Unix カーネルの伝統的なシステ
ムコールの一部を提供します．図~\ref{fig:api} は xv6 の全てのシステムコー
ルです．

この章の続きでは，xv6 の提供するサービスの概要を述べます．すなわち，プ
ロセス，メモリ，ファイルディスクリプタ，パイプ，およびファイルシステム
です．それらをコードと合わせて説明するとともに，Unix 的システムにおける
重要なユーザインタフェースである\indextext{シェル}が，どのようにそれらを利用するか議
論します．シェルがシステムコールを利用する様は，システムコールがいかに
繊細に設計されたかをよく示しています．


シェルはありふれたプログラムで，ユーザが入力したコマンドを読み込み，そ
れを実行します．シェルがユーザプログラムであり，カーネルの一部ではない
という事実は，システムコールインターフェースの力を示します．シェル
は決して特別なプログラムでは無いのです．つまり，シェルは簡単に取
替えることができます．現代的な Unix システムでは，
さまざまなシェルを選ぶことができて，それらは独自のユーザインタフェースとス
クリプティング機能を持っています．xv6 シェルは Unix Bourne シェル
のエッセンスのみを取り出した単純な実装です．実装は
\lineref{user/sh.c:1} にあります．

%% 
%% 	Processes and memory
%% 
\section{プロセスとメモリ}

xv6 のプロセスは，ユーザ空間のメモリ（命令列，データ，およびスタック）
と，カーネルだけが見ることができるプロセス固有の状態を持ちます．xv6 は
プロセス間で\indextext{タイムシェア} (\indextext{Time share}) を行います．すなわち，実行待ちを
しているプロセスを，利用可能な（複数の）CPU に対して透過的に切り替えま
す．プロセスが実行状態でないとき，xv6 は CPU レジスタを退避しておき，
実行するときに復元します．カーネルは各プロセスに対し，プロセス ID （ある
いは \indexcode{pid}）を割り当てます．


\begin{figure}[t]
\center
{\footnotesize
\begin{tabular}{ll}
{\bf システムコール} & {\bf 説明} \\
\midrule
\texttt{fork()} & プロセスを作る．\\
\texttt{exit(xstatus)} & 現在のプロセスを終了．\texttt{xstatus} で成否を示す．\\
\texttt{wait(*xstatus)} & 子プロセスの終了を待ち，終了コードを \texttt{xstatus} にコピーする．\\
\texttt{kill(pid)} & \texttt{pid} 番のプロセスを終了する．\\
\texttt{getpid()} & 現在のプロセスのプロセスID (PID) をリターンする．\\
\texttt{sleep(n)} & \texttt{n} クロック刻みのあいだスリープする．\\
\texttt{exec(filename, *argv)} & ファイルをロードして実行する．\\
\texttt{sbrk(n)} & プロセスのメモリを \texttt{n} バイト増やす．\\
\texttt{open(filename, flags)} & ファイルを開く．\texttt{flags} は読み書きを示す．\\
\texttt{read(fd, buf, n)} & 開いているファイルから \texttt{n} バイト読み，\texttt{buf} に入れる．\\
\texttt{write(fd, buf, n)} & 開いているファイルに \texttt{n} バイト書き込む．\\
\texttt{close(fd)} & 開いているファイルを表す \texttt{fd} を解放する．\\
\texttt{dup(fd)} & \texttt{fd} を複製する．\\
\texttt{pipe(p)} & パイプを作り，そのファイルディスクリプタ (fd) を \texttt{p} に入れる．\\
\texttt{chdir(dirname)} & カレントディレクトリを変更する．\\
\texttt{mkdir(dirname)} & 新しいディレクトリを作る．\\
\texttt{mknod(name, major, minor)} & デバイスファイルを作る．\\
\texttt{fstat(fd)} & 開いているファイルに関する情報をリターンする．\\
\texttt{link(f1, f2) } & ファイル \texttt{f1} の別の名前 (\texttt{f2}) を作る．\\
\texttt{unlink(filename)} & ファイルを消去する．
\end{tabular}
}
\caption{xv6 のシステムコール}
\label{fig:api}
\end{figure}

プロセスは，\indexcode{fork} システムコールを利用することで，新しいプロセ
スを生むことができます．\indexcode{fork} は呼び出し元（\indextext{親プロセス}と呼びま
す）とまったく同一のメモリを持つ新しいプロセス（\indextext{子プロセス}と呼びます）
を作ります．\lstinline{fork} は，親プロセスと子プロセスの両方にリターンし
ます．親プロセスにおいて，\indexcode{fork} の返値は子プロセス
の \indexcode{pid} です．一方，子プロセスにおける \indexcode{fork} の
返値は 0 です．たとえば，C言語で書かれた次のプログラムを考えてみましょう~\cite{kernighan}:
%
\begin{lstlisting}[]
int pid = fork();
if(pid > 0){
  printf("parent: child=%d\en", pid);
  pid = wait(0);
  printf("child %d is done\en", pid);
} else if(pid == 0){
  printf("child: exiting\en");
  exit(0);
} else {
  printf("fork error\en");
}
\end{lstlisting}
\indexcode{exit} システムコールは呼んだプロセスの実行を中止し，メモリや開
いているファイルなどのリソースを解放します．\indexcode{exit} は整数のステー
タス引数を取ります．慣習的に，0が成功, 1が失敗を表しま
す．\indexcode{wait} システムコールは，終了した子プロセスの \indexcode{pid}
をリターンするとともに，子プロセスの終了ステータスを，\indexcode{wait} に
渡されたアドレスへコピーします．もし，どの子プロセスも終了
しない場合，\indexcode{wait} はどれかが終了するまで待ちます．もし，親プロ
セスが子プロセスの終了コードに興味がない場合は，引数に 0 を渡します．


上記の例において，
\begin{lstlisting}[]
parent: child=1234
child: exiting
\end{lstlisting}
のような出力が順不同で現れます．親プロセスと子プロセスのどちらが先
に \indexcode{printf} を呼んだかによって順序が決まります．子プロセスが終了
したあと，親プロセスの \indexcode{wait} はリターンし，その結果親プロセスは次
を出力します:
\begin{lstlisting}[]
parent: child 1234 is done
\end{lstlisting}
初期状態の子プロセスは，親プロセスとメモリ内容は同じですが，
別のメモリとレジスタを使って実行を行います．すなわち，一方で
加えた変更は，もう一方には伝わりません．たとえば，親プロセスにおいて
\indexcode{wait} の返値が \indexcode{pid} 変数に代入されたとしても，
それは子プロセスの \indexcode{pid} 変数は変更しません．子プロセスの
\indexcode{pid} 変数は変わらず 0 を保持します．

\indexcode{exec} システムコールは，呼び出し元プロセスのメモリを，ファイル
システムから読み出したファイルをロードしたメモリイメージに取り替え
ます．そのファイルは，ファイルのどの部分が命令列か，どの部分がデータか，
またどの命令列から実行を開始するか，などの情報を持つ特定のフォーマットに従っ
ている必要があります．xv6 が利用する ELF フォーマットについて
は \ref{CH:MEM}~章で詳しく説明します．成功した \indexcode{exec} は，呼び出し元プログ
ラムにはリターンしません．そのかわり，そのファイルから読み出された命令
列の中で，ELF ヘッダにおいてエントリポイントと指定された命令にリター
ンします．\indexcode{exec} は2つの引数を取ります．実行可能ファイルのファイ
ル名と，文字列引数の配列です．以下が例です．
\begin{lstlisting}[]
char *argv[3];

argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\en");
\end{lstlisting}
このコード片は，呼び出し元プログラムを，\lstinline{echo hello} という引数
で実行する\lstinline{/bin/echo} というプログラムに取り替えます．最初の引数
には慣習上プログラム名を指定しますが，多くのプログラムはこれを無視しま
す．

xv6 のシェルは，上記のシステムコールを使うことで，ユーザにかわってプロ
グラムを実行します．\lineref{user/sh.c:/main/} の \lstinline{main} から分かるように，
シェルの主構造は単純です．メインループは \indexcode{getcmd} を用いて，ユー
ザ入力を 1 行読み込みます．そのあと，シェルは \lstinline{fork} を呼んでシェ
ルプロセスのコピーを作ります．子プロセスがコマンドを実行する間，親プロ
セスは \lstinline{wait} を呼びます．たとえば，ユーザが入力したコマンド
が 
``\lstinline{echo hello}''
であった場合，\lstinline{runcmd} は 
``\lstinline{echo hello}''
を引数として呼び出されます．実際にコマンドを実行するの
は \lstinline{runcmd} \lineref{user/sh.c:/runcmd/} です．
``\lstinline{echo hello}''
コマンドに対して
は，\lstinline{exec} を呼び出します \lineref{user/sh.c:/exec.ecmd/}．ある時点
で \lstinline{echo} は \lstinline{exit} を呼び，それによって親プロセス
は\lstinline{wait} から \lstinline{main} にリターンします \lineref{user/sh.c:/main/}．


なぜ \indexcode{fork} と \indexcode{exec} を合わせて 1 つのシステムコールにしない
のか疑問に思うかもしれません．のちほど，プロセス生成とプログラムの
ロードを分けて呼ぶことが，シェルの I/O リダイレクションで
賢く使われている例を見ます．上記の \lstinline{fork} の利用例において，重
複したプロセスを作る無駄を避けるために，カーネルはコピーオンライト (copy-on-write) などの
仮想メモリのテクニックを用いて \lstinline{fork} の実装を最適化しています．

xv6 は，ユーザ空間のメモリを暗黙のうちにアロケート (allocate) しま
す．\indexcode{fork} は子プロセスが親プロセスのメモリのコピーを得るのに必
要なメモリをアロケートし，\indexcode{exec} は実行可能ファイルを保持するの
に必要なメモリをアロケートします．実行時に（多くの場
合 \indexcode{malloc}によって）さらにメモリが必要になったプロセス
は \lstinline{sbrk(n)} を呼ぶことで，データメモリを \lstinline{n} バイト増加させること
ができます．\indexcode{sbrk} は新しいメモリの場所をリターンしま
す．

xv6 は，ユーザや，あるユーザから別のユーザの保護といった概念を提供しません．
Unix の言葉で言えば，xv6 の全てのプロセスは root として実行します．

%% 
%% 	I/O and File descriptors
%% 
\section{I/O とファイルディスクリプタ}

\indextext{ファイルディスクリプタは}，カーネルが管理するオブジェクトで，プロセスが
読み書きするものを表す小さい整数です．プロセスがファイルディスクリプタ
を得るのは，ファイル，ディレクトリ，あるいはデバイスを開いたときや，ある
いはパイプを作ったり，既存のディスクリプタをコピーしたときです．簡単の
ため，ファイルディスクリプタが指し示すオブジェクトを，単に「ファイル」と呼
びます．ファイルディスクリプタインタフェースは，ファイルや，パイプや，デ
バイスなどの差異を抽象化して，どれもバイトのストリームのように見せます．


xv6 カーネルは内部的に，プロセス固有のテーブルのインデックスとしてファ
イルディスクリプタを利用します．どのプロセスも，そのプロセスに固有な 0
から始まるファイルディスクリプタを持っています．慣習上，プロセスは0番ファ
イルディスクリプタ（標準入力）から読み込み，1番ファイルディスクリプタ
（標準出力）に書き込み，2番ファイルディスクリプタ（標準エラー出
力）にエラーメッセージを書き込みます．のちほど見るように，シェルはこの
慣習を利用して I/O リダイレクションとパイプラインを実装します．シェルは，
全てのプロセスがこれら3つのファイルディスクリプタが開いていることを
保証します \lineref{user/sh.c:/open..console/}．これらは，デフォルトではコンソールのファイル
ディスクリプタです．


\lstinline{read} と \lstinline{write} システムコールは，ファイルディスクリプ
タが指すファイルに対し，バイト列を読み出したり書き込んだりしま
す．\lstinline{read(fd, buf, n)} は，ファイルディスクリプタ \lstinline{fd} か
ら最大で \lstinline{n} バイトを読み出し，それを \lstinline{buf} にコピーした
上で，読みだしたバイト数をリターンします．ファイルに関連づいたファイル
ディスクリプタにはオフセットがあります．\lstinline{read} は，現
在のオフセットを起点に読み込みを行い，読んだ分だけオフセットを増加させ
ます．そのあとに呼び出される \lstinline{read} は，先の \lstinline{read} が読ん
だものに続くバイト列を返します．もしそれ以上読み込むバイトが無いとき，
\lstinline{read} は 0 をリターンして，ファイルの終端であることを示します．

\lstinline{write(fd, buf, n)} は，\lstinline{buf} からファイルディ
スクリプタ \lstinline{fd}に \lstinline{n} バイトを書き込み，書き込んだバイト
数をリターンします．返値が \lstinline{n} より少なくなるのはエラーのときだけ
です．\lstinline{read} と同様に，\lstinline{write} はそのファイルの現在のオフ
セットに書き込みを行い，書き込んだバイト数分オフセットを進めま
す．続く \lstinline{write} は，以前の \lstinline{write} が終えた場所から始めま
す．

次のコード片は \lstinline{cat} の本質的な部分であり，標準入力のデータを標準出力
にコピーします．もしエラーが生じたら，それを標準エラー出力へ書き込みます．
\begin{lstlisting}[]
char buf[512];
int n;

for(;;){
  n = read(0, buf, sizeof buf);
  if(n == 0)
    break;
  if(n < 0){
    fprintf(2, "read error\en");
    exit();
  }
  if(write(1, buf, n) != n){
    fprintf(2, "write error\en");
    exit();
  }
}
\end{lstlisting}
ここで重要なのは，このコード片において，読み込み元がファイル，コンソール，およびパ
イプなどのいずれであるか，\lstinline{cat} は関知しないということです．
同様に，\lstinline{cat} は書き込んでいる先がコンソールなのか，ファイルなの
か，あるいは何か別のものなのかにも関知しません．ファイルディスクリプタを使うことと，
0番ファイルディスクリプタは入力・1番ファイルディスクリプタは出力であるという慣習が，
\lstinline{cat} の実装を単純化しています．

\lstinline{close} システムコールはファイルディスクリプタを解放して，将来
の \lstinline{open}, \lstinline{pipe}, あるいは \lstinline{dup} システムコール
（後述します）が再利用できるようにします．新たにアロケートされたファイルディ
スクリプタは常に，そのプロセスの未使用ファイルディスクリプタのうち，
最小の値を取ります．


ファイルディスクリプタと \indexcode{fork} を使うことで，I/O リダイレクショ
ンを簡単に実装することができます．\lstinline{fork} は，メモリとともに，親
プロセスのファイルディスクリプタテーブルをコピーします．そのため，子プ
ロセスは親プロセスと全く同じファイルを開いた状態で開始しま
す．\indexcode{exec} システムコールは，呼び出し元プロセスのメモリを取り替
えますが，ファイルテーブルはそのままにしておきます．そのことを利用して，
シェルは I/O リダイレクションを実現します: \lstinline{fork}
を呼ぶ，選択したファイルディスクリプタを再度開く，新しいプログラム
を \lstinline{exec} する．
%
以下は，\lstinline{cat < input.txt} に対してシェルが実行する
コードを単純化したものです:
\begin{lstlisting}[]
char *argv[2];

argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
  close(0);
  open("input.txt", O_RDONLY);
  exec("cat", argv);
}
\end{lstlisting}
子プロセスはファイルディスクリプタ 0 番を閉じたあと，\lstinline{open} シス
テムコールで \lstinline{input.txt} を開きます．それにより得るファイルディ
スクリプタは 0 番です．0 が未使用ディスクリプタの中で最小だからで
す．\lstinline{cat} はそのあと，\lstinline{input.txt} に関連づいたファイルディ
スクリプタ 0 番を用いてプログラムを実行します．


xv6 シェルにおける I/O リダイレクションは，まさにその方法で動いていま
す \lineref{user/sh.c:/case.REDIR/}．この時点でシェルはすでに子プロセス
を \lstinline{fork} しており，\lstinline{runcmd} がこれから \lstinline{exec} を
読んで新しいプログラムをロードするのでした．ここ
で，\lstinline{fork} と\lstinline{exec} を分けておくのが良いアイディアである
ことが明らかになるはずです．それらが分かれていることにより，シェルは子
プロセスを \lstinline{fork} したあと，子プロセスにおいて \lstinline{open},
\lstinline{close}, および \lstinline{dup} を用いて標準入出力のファイルディス
クリプタを変更し，そのあとに \lstinline{exec} を呼ぶことができるので
す．\lstinline{exec} で呼ばれる側 (例では \lstinline{cat}) の変更は不要です．
もし \lstinline{fork} と \lstinline{exec} が合わせて 1 つのシステムコールであっ
たら，シェルが標準入出力をリダイレクトするのにそのほかの（たぶんもっと
複雑な）方法を使うか，もしくは呼ばれるプログラム自身が I/O をどうやっ
てリダイレクトするか理解する必要があります．


\lstinline{fork} はファイルディスクリプタテーブルをコピーしますが，
対応するファイルのオフセットは親プロセスと子プロセスで共有されています．
次の例を考えてみます:
\begin{lstlisting}[]
if(fork() == 0) {
  write(1, "hello ", 6);
  exit(0);
} else {
  wait(0);
  write(1, "world\en", 6);
}
\end{lstlisting}
このコード片の最後において，ファイルディスクリプタ 1 番に対応するファイルには，
\lstinline{hello world} というデータが入っているはずです．親プロセスにおける
\lstinline{write} (\lstinline{wait} のおかげで必ず子プロセスのあとに実行される)
は，子プロセスの \lstinline{write} が終わった箇所から始めることができます．
この挙動は，シェルコマンドの列から，出力を順番に取り出すのに役に立ちます．
たとえば，\lstinline{(echo hello; echo world)>output.txt} です．


\lstinline{dup} システムコールは，既存のファイルディスクリプタを複製し，元と
同じ I/O オブジェクトを参照する新しいファイルディスクリプタをリターンし
ます．複製されたファイルディスクリプタは，元のディスクリプタとオフセッ
トを共有します．\lstinline{fork} で複製された場合と同様です．
以下は，\lstinline{hello world} をファイルに書き込む別の方法です．
\begin{lstlisting}[]
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\en", 6);
\end{lstlisting}


\lstinline{fork} の後に \lstinline{dup} を呼ぶことで得た（同一のファイ
ルディスクリプタから複製された）2 つのファイルディスクリプタはオフセッ
トを共有します．それ以外の場合では，たとえ同一のファイル
を \lstinline{open} して得たファイルディスクリプタであっても，オフセッ
トを共有することはありません．

\lstinline{dup} により，シェルは次のようなコマンドを
実現できます．
\lstinline{ls}
\lstinline{existing-file}
\lstinline{non-existing-file}
\lstinline{>}
\lstinline{tmp1}
\lstinline{2>&1}.
ここで
\lstinline{2>&1}
は，ファイルディスクリプタ 2 番は 1 番の複製であると
シェルに伝えます．存在するファイル名と
存在しないファイルに対するエラーメッセージの両方が
\lstinline{tmp1} に現れることになります．
xv6 のシェルはエラーファイルディスクリプタの I/O リダイレクションは
サポートしませんが，これでどうやって実装すればよいか分かったはずです．
ファイルディスクリプタはつながっている先の詳細を隠してくれる
強力な抽象化です．あるプロセスがファイルディスクリプタ 1 番に書き込みを
行うとき，実際の書き込み先はファイル，コンソールなどのデバイス，
およびパイプのいずれでもありえます．

%% 
%% 	Pipes
%% 
\section{パイプ}

\indextext{パイプ}とはカーネルの小さいバッファで，プロセスに対しては一対のファイル
ディスクリプタに見えます: 片方は読み出し，もう片方は書き込み
用です．データをパイプの一方に書き込むと，そのデータはパイプのもう一方
から読み出すことができるようになります．パイプを用いると，プロセス間で
通信を行うことができます．


次のプログラムは，\lstinline{wc} プログラムを，パイプの読み出し側を
標準入力に接続して実行します．
\begin{lstlisting}[]
int p[2];
char *argv[2];

argv[0] = "wc";
argv[1] = 0;

pipe(p);
if(fork() == 0) {
  close(0);
  dup(p[0]);
  close(p[0]);
  close(p[1]);
  exec("/bin/wc", argv);
} else {
  close(p[0]);
  write(p[1], "hello world\en", 12);
  close(p[1]);
}
\end{lstlisting}
このプログラムは \lstinline{pipe} を呼んで新しいパイプを作り，読み書
き用のファイルディスクリプタを配列 \lstinline{p} に記録しま
す．\lstinline{fork} のあと，親プロセスと子プロセスはそのパイプに関連づいた
ファイルディスクリプタを持ちます．子プロセスはパイプの読み出し側をファ
イルディスクリプタ0番に \lstinline{dup} で複製し，\lstinline{p} のファイルディスク
リプタを閉じ，そのあとで \lstinline{wc} を \lstinline{exec} しま
す．\lstinline{wc} が標準入力から読み出しを行うと，パイプから読み込みが行
われます．親プロセスはパイプの読み出し側を閉じ，パイプに対して書き込み
を行い，そして最後にパイプの書き込み側を閉じます．


もしデータが来ていない場合，パイプへの \lstinline{read} は新しいデータが到
来するか，パイプの書き込み側のファイルディスクリプタが全て閉じられるま
で待ちます．後者の場合，\lstinline{read} は，あたかもファイルの終端に達し
たかのように 0 をリターンします．新データの到来がありえなくなるま
で \lstinline{read} がブロックするすることは，子プロセスにおいてパイプの書き
込み側を閉じなくてはいけない理由の 1 つです．もし \lstinline{wc} のファイ
ルディスクリプタの 1 つがパイプの書き込み側を指していた場
合，\lstinline{wc} は決してファイル終端にたどり着けません．


xv6 シェルは \lstinline{grep fork sh.c | wc -l} のようなパイプラインを，上
記のコードのような方法で実装しています(user/sh.c:100)．子プロセスはパイ
プラインの左側から右側までをつなぐためにパイプを作ります．そのあと，左側
のコマンドのために \lstinline{fork} と \lstinline{runcmd} を呼び，そのあと，右
側のコマンドのために \lstinline{fork} と \lstinline{runcmd} を呼びます．最後
に，両方が終わるまで待ちます．パイプラインの右側は，さらにパイプを含む
ことができます（たとえば \lstinline{a | b | c}）．それはさら
に2つの新しい子プロセスに \lstinline{fork} します(すなわ
ち \lstinline{b} と \lstinline{c}です)，そのようにして，シェルはプロセスのツ
リーを作ることができます．ツリーの葉はコマンドで，内側のノードは左右の
子プロセスの完了を待つためのプロセスとなります．原理的には，内側のノー
ドにパイプラインの左側の処理を割り当てることも可能ですが，正しく
実行しようとすると実装が複雑になってしまうでしょう．

パイプをテンポラリファイルと比べた利点は分かりづらいかもしれません．
次のパイプライン
\begin{lstlisting}[]
echo hello world | wc
\end{lstlisting}
は，パイプラインを使わずに次のようにしても実装できるからです．
\begin{lstlisting}[]
echo hello world >/tmp/xyz; wc </tmp/xyz
\end{lstlisting}
この使い方において，パイプのテンポラリファイルに対する利点は少なくと
も 4 つあります．第一に，パイプは自動で消えます．ファイルのリダイレクショ
ンを使う場合，シェルは終了後に \lstinline{/tmp/xyz} を消すように気をつけな
くてはいけません．第二に，パイプは任意に長いデータのストリームを渡す
ことができます．それに対しリダイレクションでは，データ全体を保存す
るための領域がディスクに必要です．第三に，パイプでは，
パイプラインの各ステージを並列に実行させることができます．ファイルを使
うアプローチでは，先のプログラムが完了したあとで無いと，次のプログ
ラムを開始できません．第四に，プロセス間通信に利用する場合，パイプの
ブロック付きの読み書きは，ファイルへのブロックなし読み書きよりもずっと
効率的です．

%% 
%% 	File system
%% 
\section{ファイルシステム}

xv6 のファイルシステムは単なるバイト配列であるデータファイルと，ディレク
トリを提供します．ディレクトリは，データファイル・ディレクトリの名
前とその場所を提供します．ディレクトリはツリーを構成します．その起点は
\indextext{ルート}と呼ばれる特別なディレクトリです．\lstinline{/a/b/c} のよう
な\indextext{パス}は，\lstinline{c} という名のファイルまたはディレクトリ
が，\lstinline{b} というディレクトリに入っていて，それは更に \lstinline{a} と
いうルートディレクトリに入っているディレクトリに入っていることを意味し
ます．\lstinline{/} から始まらないパスは，呼び出し元プロセスのカレントディ
レクトリから相対的に評価されます．以下のコード片はいずれも同じファイル
を開きます（関係するディレクトリは存在するものとします）:
\begin{lstlisting}[]
chdir("/a");
chdir("b");
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);
\end{lstlisting}
1つ目コード片は，そのプロセスのディレクトリを \lstinline{/a/b} に移動します．
それに対して2つ目のコード片は，カレントディレクトリを参照することも変更することも
しません．


新しいファイルやディレクトリを作るためのシステムコールはいくつもあります．
\lstinline{mkdir} は新しいディレクトリを作ります．\lstinline{O_CREATE} フラグ付きで
\lstinline{open} すると新しいファイルを作ります．\lstinline{mknod} は新しい
デバイスファイルを作ります．以下は，それら3つ全ての例です:
\begin{lstlisting}[]
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
\end{lstlisting}
\lstinline{mknod} はファイルシステムにファイルを作成しますが，そのファイ
ルには中身がありません．そのかわり，そのファイルのメタデータにデ
バイスファイルであるマークがついており，メジャーおよびマイナーデバイス番号を
記録しています（\lstinline{mknod} の 2 つの引数で指定します）．プロセスが
そのファイルを開くと，カーネルは \lstinline{read} や \lstinline{write}
をファイルシステムではなく，カーネル内のデバイスの実装に誘導します．


\lstinline{fstat} は，ファイルディスクリプタが指し示すオブジェクトの情報を
取得します．結果は，\lstinline{stat.h} \fileref{kernel/stat.h} で定義される
\lstinline{stat} 構造体に入ります:
\begin{lstlisting}[]
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device

struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
\end{lstlisting}


ファイル名はファイルそのものとは独立です．\indextext{inode} と呼ばれる
ファイルの内部表現は複数の名前を持つことができ，それは\indextext{リンク}と呼ばれます．
\lstinline{link} システムコールは，既存ファイルの inode を指し示す
別のファイルを作成します．次のコード片は，\lstinline{a} と \lstinline{b} という
2つの名前を持つ新しいファイルを作成します:
\begin{lstlisting}[]
open("a", O_CREATE|O_WRONLY); 
link("a", "b");
\end{lstlisting}
\lstinline{a} に読み書きすることは，\lstinline{b} に読み書きすることと等価です．
各 inode は，固有の inode 番号で識別します．
上記のコードを実行したあと，\lstinline{a} と \lstinline{b} が
同じ内容を示すことは，\lstinline{fstat} で確認できます．
両者は同じ inode 番号 (\lstinline{ino}) を持ち，また \lstinline{nlink} は
2 になっているはずです．


\lstinline{unlink} システムコールは，ファイルシステムから名前を削除します．
そのファイルの inode およびファイル内容を記憶するディスク上の領域は，
ファイルのリンク数が 0 になり，かつ参照しているファイルディスクリプタが
無くなったときに限り解放されます．よって，先のコードに
\begin{lstlisting}[]
unlink("a");
\end{lstlisting}
と付け足したとしても，ファイルの inode とその内容に
は，\lstinline{b} としてアクセスできます．さらに，
\begin{lstlisting}[]
fd = open("/tmp/xyz", O_CREATE|O_RDWR); 
unlink("/tmp/xyz");
\end{lstlisting}
とすることは，そのプロセスが \lstinline{fd} を閉じたり，あるいは終了したとき
に消える一時ファイルを作成するときのイディオムです．


ファイルシステムの操作のためのシェルのコマンドは，\lstinline{mkdir},
\lstinline{ln}, \lstinline{rm} などのユーザレベルプログラムとして実装されます．
そのようにすることで，新しいユーザレベルプログラムを足すだけで，シェル
を拡張して新しいユーザコマンドを追加できます．今となっては当たり前に見
えるかもしれませんが，Unix が設計された時代，他のシステムはそのようなコ
マンドをシェルに内蔵していました（そして，シェルをカーネルに内蔵してい
ました）．

ひとつの例外は \lstinline{cd} で，それはシェルに内蔵されていま
す \lineref{user/sh.c:/if.buf.0..==..c./}．\lstinline{cd} はシェル自体のカレントディレクトリを変更
しなくてはいけません．もし \lstinline{cd} が通常コマンドとして実行されると，
シェルは子プロセスを生成し，その子プロセスが \lstinline{cd} を実行すること
になります．そうすると，\textit{子プロセス}の作業ディレクトリは変化しますが，親
プロセスの（すなわちシェルの）作業ディレクトリは変化しません．

%% 
%% 	Real world
%% 
\section{世の中のオペレーティングシステム}

Unix において，「標準」のファイルディスクリプタ，パイプ，およびそれらを
使うための便利なシェルの構文が組み合わさることが，再利用性の高い
汎用プログラムを書くことの大きな利点でした．このアイディアは，Unix のパ
ワーと人気の源泉である「ソフトウェアツール」の文化に火をつけ，シェルは
いわゆる最初のスクリプト言語となりました．Unix のシステムコールインター
フェースは，今日においても，BSD, Linux, および Mac OS X などの
システムで維持されています．


Unix のシステムコールインターフェースは，Portable Operating System
Interface (POSIX) として標準化されました．xv6 は POSIX 準拠で
は\textit{ありません}．xv6 には足りないシステムコールがあったり（ごく基
本的な\lstinline{lseek}を含みます），部分的にしか実装されていないシステム
コールがあるなどの違いがあるためです．Unix 風のシステムコールインター
フェースを持ちますが，xv6 の主なゴールは単純さと明快さにあります．新し
いシステムコールや，基本的な Unix プログラムを実行するための簡単な C ラ
イブラリで xv6 を拡張する人もいます．しかしながら，現代的なカーネル
は，xv6 と比べて圧倒的に多くのシステムコールやサービスを提供しています．
たとえば，ネットワーク機能，ウィンドウシステム，ユーザレベルスレッド，
多くのデバイスドライバなどを備えています．現代的なカーネルは，持続的か
つ急速に発展しており，POSIX を超える多くの機能を提供します．


Unix から派生した現代的なオペレーティングシステムの多く
は，先に見た \lstinline{console} デバイスファイルのような，デバイスを特殊
ファイルとして扱う古き Unix モデルを採用しませんでした．Unix の作者たち
は Plan 9 に移り，「リソースはファイルである」というコンセプトを，より
現代的な設備であるネットワークやグラフィクスなどの資源に適用しました．


ファイルシステムとファイルディスクリプタは強力な抽象化でしたが，オペレー
ティングシステムには別のインターフェースもありえました．Unix の先祖であ
る Multics は，ファイルストレージをメモリのように抽象化することで，全く
異なるインタフェースを作り上げました．Multics の設計の複雑さは，Unix
の設計者たちに直接的に影響を与え，シンプルを求める原動力となりました．


この本は，xv6 がどのようにして Unix 風のインタフェースを実装するかを説
明しますが，そのアイディアとコンセプトは Unix に限らず適用できるもので
す．オペレーティングシステムであれば，どのようなものであっても，プロセ
スをハードウェアに対して切り替えたり，プロセス同士を分離したり，プロセ
ス間通信のためのメカニズムを提供したりします．xv6 を学んだあとに
より複雑なオペレーティングシステムを見れば，
xv6 と同様のコンセプトを見つけるはずです．

%% 
\section{練習問題}
%%

\begin{enumerate}

\item 2つのプロセスを（各方向からなる）1 組のパイプで接続し，ある 1 バ
  イトのデータをプロセス間で卓球のように行き来させるプログラムを，Unix
  システムコールを用いて書いてください．また，1 秒あたりの行き来の回数を
  性能評価してください．

\end{enumerate}
