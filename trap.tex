%    Sidebar about panic:
% 	panic is the kernel's last resort: the impossible has happened and the
% 	kernel does not know how to proceed.  In xv6, panic does ...
\chapter{トラップとデバイスドライバ}
\label{CH:TRAP}

あるイベントをきっかけに，CPU がいつもの逐次的な命令列の実行を中断し，
そのイベントを処理するための特別なコードに制御移すというシチュエーショ
ンが3つあります．1つ目はシステムコールで，ユーザプログラム
が \texttt{ecall} 命令を実行してカーネルに何かしてほしいと依頼す
る場合です．2つ目は\indextext{例外}です．（ユーザもしくはカーネルの）コードが何か不
正なことをしてしまった場合です．たとえばゼロで割り算をした場合や，無効な仮
想アドレスを使用した場合です．3つ目はデバイスによる\indextext{割込}で，デバイス
が何か気づいて欲しいことがある場合です．たとえば，ディスクのハードウェ
アが，リクエストされていた読み込みや書き込み処理を完了したときなどです．

この本では，これらの3つのシチュエーションを\indextext{トラップ}と総称します．通
常，トラップ発生時にもともと実行していたコードは，あとから再開できなくては
ならず，また，何か特別なことが生じたと気づくことがあってはなりません．
すなわち，トラップは透過的であることを望みます．透過的で
あることは，割込について特に重要です．割り込まれることは，通常，割り込
まれたコードにとって予想外のはずだからです．よって，通常の処理は次のよ
うなものになります：トラップが強制的に処理をカーネルに移し，カーネルが
再開に必要なレジスタやそのほかの状態を退避し，カーネルが適切なハンドラ
のコード（すなわちシステムコールやデバイスドライバの実装）を呼び出し，
それが終わったら，退避しておいた状態をカーネルが復元し，トラップからリ
ターンする．そうすることで，元のコードは中断したところから再開すること
ができます．

xv6 カーネルは全てのトラップを処理します．システムコールを処理するのは
当然でしょう．割込を扱うのも納得できます．分離をしなくてはいけないので，
ユーザプロセスがデバイスを直接使えてはいけないからです．また，デバイス
を制御するための状態は，カーネルだけが持っているためです．例外について
も納得できると思います．ユーザ空間届くどんな例外も，xv6 はその犯人を殺
すことで対処するからです．

xv6 のトラップの処理プロセスは4ステージからなります．すなわち，(i)
RISC-V CPU が行うハードウェア的なアクション，(ii) カーネルの C コードを
指すアセンブリで書かれた「ベクタ」，(iii) そのトラップに対して何をする
か決める C で書かれたトラップハンドラ，(iv) システムコールもしくはデバ
イスドライバのサービスルーチンです．3 つのトラップの種類の共通性を考える
と，1つのコードパスで全てのトラップを扱うこともできそうですが，3
つのケースごとにアセンブリのベクタや C のトラップハンドラを用意してお
くと便利だということがわかります．3つのケースとは，カーネル空間からのト
ラップ，ユーザ空間からのトラップ，そしてタイマ割込です．

この章の最後ではデバイスドライバについて議論します．デバイスの制御は
トラップとは独立のトピックですが，カーネルとデバイスの相互通信は，割込
によって行われることが多いので，この章に置いてあります．

\section{RISC-V のトラップ機構}

RISC-V にはいくつもの制御レジスタがあり，カーネルがそれらに書き込むこ
とで CPU にどのように割込を扱うか指示したり，読むこ
とで発生した割込について知ることができます．RISC-V のドキュメントには
完全な内容が書いてあります~\cite{riscv:priv}．\texttt{riscv.h} 
\lineref{kernel/riscv.h:1}
には，xv6 が利用する定義が入っています．以下が，重要なレジスタの概要です．


\begin{itemize}

\item {\bf stvec}: カーネルはトラップハンドラのアドレスをここ
  に書き込みます．RISC-V はトラップが来たらそのアドレスにジャンプします．

\item {\bf sepc}: トラップが発生したら，RISC-V はプログラムカウンタ
  をここに退避します (\texttt{pc} は，直後に \texttt{stvec} の値で上書
  きされてしまうからです)．\texttt{sret} (return from trap) 命令
  は \texttt{sepc} を\texttt{pc} にコピーします．
  カーネルは，\texttt{sepc} に書き込むことで，\texttt{sret} の飛び先を
  制御します．

\item {\bf scause}: RISC-V はトラップの理由を表す番号をここに置きます．

\item {\bf sscratch}: カーネルは，トラップハンドラの一番最初で便利に
  なる値をここに置きます．

\item {\bf sstatus}: SIE ビットが，デバイス割込が有効かどう
  かを制御します．RISC-V は SIE がセットされるまで，デバイス割
  込を遅延させます．SPP ビットは，そのトラップがユーザモードから
  来たのかスーパーバイザモードから来たのかを示します．そして，\texttt{sret} 
  が返るときのモードを制御します．

\end{itemize}

上記は，スーパーバイザモードで処理される割込に関連しており，それらはユー
ザモードで読み書きできてはいけません．マシンモードで割込を処理するため
に，また別の制御レジスタ一式があります．xv6 はそれらを，タイマ割込の
特別な場合でのみ利用します．

トラップを強制しなくてはいけないとき，RISC-V はどのトラップに対しても
次のことをします（ただしタイマ割込を除きます）
\begin{enumerate}
\item トラップがデバイスの割込で, \texttt{sstatus} の SIE ビッ
  トがゼロだったら，続く処理は行わない．

\item SIE をゼロにして割込を無効化する．

\item \texttt{pc} を \texttt{sepc} にコピーする.

\item 現在のモード（ユーザもしくはスーパーバイザ）を，\texttt{sstatus} の SPP ビットにセーブする．

\item 割込の原因を表すように \texttt{scause} をセットする．

\item スーパーバイザモードにする．

\item \texttt{stvec} を \texttt{pc} にコピーする.

\item 新しい \texttt{pc} で実行を開始する.

\end{enumerate}

CPU が，以上のステップを単一のオペレーションとして行うのが重要です．以
上のうち1つを取り除いた場合を考えてみてください．たとえば，CPU がプログ
ラムカウンタを切り替えなかった場合などです．その場合，ユーザの命令列を
実行しているにも関わらず，トラップがスーパーバイザモードへの切り替えを
行ってしまう可能性があります．それは，ユーザとカーネルの分離を壊す可能
性があります．たとえば，誰でもアクセスできる物理メモリの領域を指すよう
に \texttt{satp} レジスタを書き換えてしまう場合などです．よって，
ユーザプログラムではなく，カーネルがトラップのエントリポイントを指定する
ことが重要なのです．

CPU は次のことはしてくれません: カーネルページテーブルの切り替え，カー
ネルのスタックへの切り替え，\texttt{pc} 以外のレジスタの退避．よって，
カーネルが，必要に応じて上記の処理を行わなくてはいけません．トラップ時
に CPU が最小限のことしか行わないのは，ソフトウェアに柔軟性を与えるため
です．ページテーブルの切り替えが不要なシチュエーションもあり，そのときに
性能を向上させることができます．

\section{カーネル空間からのトラップ}

xv6 カーネルが CPU 上で実行しているとき，2 種類のトラップが発生する可能性
があります．すなわち，例外とデバイス割込です．それらのトラップに対して CPU が
どのように応答するかは，前セクションで説明しました．

カーネルが実行中のとき，\texttt{stvec} は \texttt{kernelvec}
\lineref{kernel/kernelvec.S:/^kernelvec/} にあるアセンブリコードを指しています．xv6 はす
でにカーネルにいますので，\texttt{kernelvec} は，\texttt{satp} はすでに
カーネルページテーブルを指しており，スタックポインタは正しくカーネルス
タックを指していると想定できます．\texttt{kernelvec} は，割り込まれたコードが
問題なくあとから再開できるよう，全てのレジスタを退避します．

\texttt{kernelvec} によるレジスタの退避は，割り込まれたカーネルスレッド
のカーネルスタックに対して行います．退避するレジスタは，その
スレッドに属しているためです．それは，トラップが別のスレッドへの切り替
えを引き起こすときに特に重要です．その場合トラップは，切り替え先スレッ
ドのスタックを用いてリターンを行います．そのあいだ，退避されたレジスタは，
割り込まれたスレッドのスタックに安全に保存されます．

\texttt{kernelvec} は，レジスタを退避したあと，\texttt{kerneltrap}
\lineref{kernel/trap.c:/^kerneltrap/}
にジャンプします．\texttt{kerneltrap} はデバイス割
込と例外のためにあります．\texttt{kerneltrap} は，デバイス割込のためのチェック
と処理を，\texttt{devintr} 
\lineref{kernel/trap.c:/^devintr/}
を呼ぶことで行います．も
し，そのトラップがデバイス割込でなかったとき，すなわち例外であったとき，
それがカーネル内で生じるということはいつでも致命的エラーを意味します．

\texttt{kerneltrap} がタイマ割込により呼び出された場合で，かつあるプロ
セスのカーネルスレッド（つまりスケジューラではないスレッド）が実行中だっ
たら，\texttt{kerneltrap} は \texttt{yield} を呼び出して，他のスレッド
に実行を譲ります．いずれ，どれかのスレッド
が \texttt{yield} を呼び出すことで，私達が今注目しているスレッドとそ
の \texttt{kerneltrap} が再開できます．\texttt{yield} が何をするか
は，\ref{CH:SCHED}~章で説明を行います．

\texttt{kerneltrap} のしごとが終わったら，トラップによって割り込まれた
コードにリターンしなくてはいけません．\texttt{yield} は，退避し
てあった \texttt{sepc} と\texttt{sstatus} の前モードを書き換えたかもし
れないので，\texttt{kerneltrap} 開始時にまずそれらを復元します．
\texttt{kerneltrap} はそれらの制御ジスタを復元してか
ら，\texttt{kernelvec} 
\lineref{kernel/kernelvec.S:/call.kerneltrap$/}
にリターンします．
\texttt{kernelvec} は，スタックに退避されていたレジスタを取り出して
復元し，\texttt{sret} を実行します．それにより，\texttt{sepc} が
\texttt{pc} にコピーされ，割り込まれていたカーネルコードが再開します．

タイマ割込時に，\texttt{kerneltrap} が \texttt{yield} を呼んで
いた場合，トラップからどのようにリターンするか考えてみるのはよいことです．

xv6 は，CPU がカーネル空間からユーザ空間に入ると
き，CPU の \texttt{stvec} を \texttt{kernelvec} にセットします．これ
は，\texttt{usertrap} 
\lineref{kernel/trap.c:/stvec.*kernelvec/}
に書いてあります．すでにカーネ
ルが実行をしているにもかかわらず，\texttt{stvec} が誤った値を保持してい
る瞬間が存在するため，その間はデバイス割込を無効にしなくてはいけません．
便利なことに，RISC-V はトラップの処理を開始するときは常に割込を無効にし
ます．そのため，xv6 が割込を再度有効にするのは，\texttt{stvec} に適切な
値をセットしたあとです．

\section{ユーザ空間からのトラップ}

ユーザ空間にいるとき，次のような原因でトラップが発生する可能性がありま
す: ユーザプログラムが(\texttt{ecall}命令により)システムコールを呼んだ
とき，なにか不正なことをしたとき，あるいはデバイスが割込を行ったとき．
ユーザ空間でトラップが生じたときの実行パスは，\texttt{uservec}
\lineref{kernel/trampoline.S:/^uservec/},
から \texttt{usertrap}
\lineref{kernel/trap.c:/^usertrap/};
に続
きます．一方，リターンするときは，\texttt{usertrapret}
\lineref{kernel/trap.c:/^usertrapret/}
のあと \texttt{userret} 
\lineref{kernel/trampoline.S:/^uservec/}
となります.

ユーザコードからのトラップは，カーネルからのトラップよりも難しいです．
なぜなら，\texttt{satp} がカーネルではなくユーザのページテーブルを指し
ており，またスタックポインタには不正（場合よっては悪意を持った）な値が
入っているかもしれないからです．

RISC-V のハードウェアは，トラップ中にページテーブルを切り替えないの
で，\texttt{stvec} が指すトラップベクタの命令列は，ユーザページテーブル
に入っている必要があります．さらにトラップベクタは，\texttt{satp} を
カーネルのページテーブルに切り替えるので，その際にクラッシュしないよう
に，トラップベクタの命令列は，カーネルのページテーブルとユーザのページ
テーブルで，同じアドレスにマップされていなくてはいけません．

xv6 は，上記の制約を，トラップベクタのコードを含む\indextext{トランポリン}ページを使うことで
解決します．xv6 はトランポリンページを，カーネルのページテーブルと全てのユーザの
ページテーブルにおいて，共通の仮想アドレスにマップします．この仮想アドレスは
（図~\ref{fig:as} と 図~\ref{fig:xv6_layout} で見たように）\indexcode{TRAMPOLINE} です．トランポリンの中身は，
\texttt{trampoline.S} でセットされます．そして，（ユーザコードを実行しているあい
だは）\texttt{stvec} は\texttt{uservec} 
\lineref{kernel/trampoline.S:/^uservec/}
を指しています.

\texttt{uservec} が開始すると，全てのレジスタは割り込むコードの値を持つことにな
ります．しかし，\texttt{uservec} は，\texttt{satp} をセットするためにいくつかの
レジスタを書き換える必要があるとともに，レジスタを退避する先のアドレスを生成する
必要があります．RISC-V は，\texttt{sscratch} レジスタによりそれを手伝ってくれま
す．\texttt{uservec} の先頭にある \texttt{csrrw} 命令は，\texttt{a0} レジスタの
中身を \texttt{sscratch} レジスタと入れ替えます．そうすることで，ユーザコードに
おける \texttt{a0} レジスタが退避されるとともに，\texttt{uservec} は \texttt{a0}
レジスタが使えるようになります．\texttt{a0} には，カーネルが以前に \texttt{sscratch} に
セットした何らかの値が入っています．

\texttt{uservec} の次のしごとは，ユーザが使っていたレジスタを退避することです．
ユーザ空間に入るまえに，カーネルは \texttt{sscratch} にプロセス固有の
\texttt{trapframe} 
\lineref{kernel/proc.h:/^struct.trapframe/}
をセットしており，そこには（ほかのいろいろ
なものに加え）ユーザレジスタを退避する場所があります．\texttt{satp} はまだユーザ
のカーネルページを指しているので，\texttt{uservec} が動くためには，
トラップフレームはユーザのアドレス空間にマップされていなくてはいけません．
各プロセスを作るとき，xv6 はそのプロセス用のトラップフレーム用のページを1つ
確保し，それが常にユーザの仮想アドレス \texttt{TRAPFRAME} にマップされるように調
整します．そのアドレスは，\texttt{TRAMPOLINE} のすぐ下にあります．プロセスの
\texttt{p->tf} はトラップフレームを指しています．ただし，それは物理アドレスで
あり，カーネルページテーブルを介してのみアクセスできます．

以上の準備をしておいたので，\texttt{a0} と \texttt{sscratch} を取り替えたあと，\texttt{a0} レジス
タにはそのプロセスのトラップフレームへのポインタが入ります．
\texttt{uservec} は，全てのユーザレジスタをそこに退避します．
\texttt{{sscratch}} に移動された \texttt{a0} レジスタの元の内容も退避します．

\texttt{trapframe} は次のような情報を保存しています: 現在のプロセスのカーネルス
タックへのポインタ，現在の CPU の \texttt{hartid}, \texttt{usertrap} のアドレ
ス，カーネルのページテーブルのアドレス．\texttt{uservec} はそれらの情報を利用して
\texttt{satp} をカーネルページテーブルに切り替え，そして \texttt{usertrap} を
呼び出します．

\texttt{usertrap} のしごとは \texttt{kerneltrap} と似ており，トラップの原因
を調べ，処理し，そしてリターンすることです \lineref{kernel/trap.c:/^usertrap/}．
上で述べたよう
に，\texttt{usertrap} はまず，カーネルモードの \texttt{kernelvec} から届くトラッ
プを処理するために，\texttt{stvec} を書き換えます．また \texttt{sepc} を再び
退避します．\texttt{usertrap} においてプロセス切り替えが生じ，その結果
\texttt{sepc} が書き換わった可能性があるためです．もしトラップがシステムコールだっ
た場合，\texttt{syscall} がそれを処理します．もしデバイス割込だった場合は
\texttt{devintr} です．いずれでもないときは例外であるため，カーネルはその間違い
を犯したプロセスを殺します．システムコールを処理するパスのときは，ユーザの
\texttt{pc} に 4 を足します．なぜなら，システムコール呼び出しにおいて，
\texttt{pc} は \texttt{ecall} 命令を指したままになっているからです．そのあと，
\texttt{usertrap} は，プロセスが殺されたのか，あるいはCPU を \texttt{yield} しな
くてはいけないのか（タイマ割込の場合）をチェックします．

ユーザ空間にリターンするための最初のステップは，\texttt{usertrapret} を呼び出す
ことです
\lineref{kernel/trap.c:/^usertrapret/}．
この関数は，将来に起きるユーザ空間からのトラップに
備えて RISC-V の制御レジスタを設定します．そのために，
\texttt{stvec} を \texttt{uservec} を指すようにする，\texttt{uservec} が利用
するトラップフレームのフィールドを用意する，\texttt{sepc} を以前退避して
おいたプログラムカウンタの値にセットする，などを行います．最終的に，
\texttt{usertrapret} は（ユーザとカーネルのページテーブルの両方にマップされた）
トランポリンページにある \texttt{userret} を呼び出します．そのようにするのは，
\texttt{userret} のアセンブリコードがページテーブルを切り替えるためです．

\texttt{usertrapret} が \texttt{userret} を呼ぶとき，そのプロセスのユー
ザページテーブルを \texttt{a0} レジス
タ，\texttt{TRAPFRAME} を \texttt{a1} レジスタに入れて渡します
\lineref{kernel/trampoline.S:/^userret/}.
\texttt{userret} は \texttt{satp} をプロセ
スのユーザページテーブルに切り替えます．ユーザページテーブルはトランポ
リンページと \texttt{TRAPFRAME} の両方をマップしているのでした．しかし，
カーネル空間の他のものはもうありません．繰り返しの説明となりますが，ト
ランポリンページは，ユーザ空間とカーネル空間で同じアドレスにマップされ
ているので，\texttt{satp} を切り替えたあとも，\texttt{uservec} は実行を
続けることができます．\texttt{trapret} は，トラップフレームに退避さ
れていた \texttt{a0} レジスタの中身を \texttt{sscratch} にコピーして，
近々 \texttt{TRAPFRAME} と取り替える処理に備えます．この時点か
ら，\texttt{userret} が使うことができるのは，レジスタの中身
と，トラップフレームの中身だけになります．続いて，\texttt{userret}
は退避されていたユーザレジスタをトラップフレームから復元します．ま
た，\texttt{a0} と \texttt{sscratch} の最後の交換を行い，\texttt{a0} レ
ジスタの中身を復元するとともに，次のトラップのため
に \texttt{TRAPFRAME} を保存します．最後に，\texttt{sret} を用いてユー
ザ空間にリターンします．


\section{タイマ割込}

xv6 は，時計の管理と，compute-bound プロセスの切り替えのためにタイマ割
込を用います．\texttt{usertrap} と\texttt{kerneltrap} におけ
る \texttt{yield} の呼び出しが，その切り替えを発生させます．タイマ割込
は，各 RISC-V CPU に付属するクロックハードウェアからやってきます．xv6
は，CPU に周期的に割込をするように，このクロックハードウェアをプログラ
ムします．

RISC-V では，タイマ割込をスーパーバイザモードではなく，マシンモードで受
ける必要があります．RISC-V のマシンモードにはページングが無く，独立した
制御レジスタを持っています．よって，通常の xv6 カーネルのコードをマシン
モードで実行するのは現実的ではありません．その結果，xv6 は，タイマ割込
を，上述のトラップメカニズムとは完全に別に扱います．

%% The xv6 timer interrupt handler asks the RISC-V hardware to
%% generate a ``software interrupt;'' after the timer interrupt finishes,
%% the RISC-V delivers the software interrupt in supervisor mode, using
%% the ordinary trap machinery outlined above.

\texttt{main} が始まるまえ，\texttt{start.c} においてマシンモードでコー
ドで実行するとき，タイマ割込を定期的に受けるように設定を行います
\lineref{kernel/start.c:/^timerinit/}．
そのためにやらなくてはいけないことの一部
は，\texttt{CLINT} ハードウェア（コア固有の割込発生機）をプログラムして，
ある遅延のあと割込を発生するようにします．やらなくてはならない別のこと
は，スクラッチ領域 (scratch area) を設定することです．それ
はトラップフレームに対応するもので，タイマ割込のハンドラがレジスタ
を退避したり，\texttt{CLINT} レジスタのアドレスを見つけるのに利用するも
のです．最後に，\texttt{start} は \texttt{timervec} に \texttt{mtvec}
を設定して，タイマ割込を有効にします．

タイマ割込は，ユーザやカーネルが実行中の，どんなタイミングでも発生する
ことがあります．どんなにクリティカルな処理の途中であっても，カーネルが
タイマ割込を止める方法はありません．そのため，タイマ割込のハンドラは，
割り込まれたカーネルのコードの邪魔をしないことを保証しながらしごとをする
必要があります．タイマ割込が RISC-V の「ソフトウェア割込」
を発生させ，即座にリターンするというのが基本的な戦略です．RISC-V は，通
常のトラップメカニズムに加えてソフトウェア割込を提供しており，それは
カーネルが無効化することができます．タイマ割込が発生するソフトウェア割込
のハンドラのコードは \texttt{devintr} 
\lineref{kernel/trap.c:/machine-mode.timer/} にあります．

マシンモードでのタイマ割込のベクタは \texttt{timervec}
\lineref{kernel/kernelvec.S:/^timervec/} です．
それは，いくつかのレジスタ
を(\texttt{start} が用意した) スクラッチ領域に退避
し，\texttt{CLINT} に次にタイマ割込を発生するタイミングを指示した上で，
RISC-V にソフトウェア割込を発生させます．そのあと，レジスタを復元してリターンします．
タイマ割込に関わる C コードはありません．

\section{Code: システムコールを呼ぶ}

\ref{CH:FIRST}~章では \indexcode{initcode.S} が \texttt{exec} システ
ムコールを呼ぶところまでを説明しました
\lineref{user/initcode.S:/SYS_exec/}．
ユーザから呼び出したとき，カーネルの \texttt{exec} システムコールの実装にどうやっ
てたどり着くのか見てみましょう．

ユーザコードは，\indexcode{exec} の引数を \texttt{a0} と \texttt{a1} レジ
スタに入れるとともに，\texttt{a7} レジスタにシステムコール番号を入れま
す．システムコール番号は，関数ポインタのテーブルであ
る \texttt{syscalls} 配列の添字となっています
\lineref{kernel/syscall.c:/syscalls/}．
\lstinline{ecall} 命令はトラップを発生させてカー
ネルに入り，これまで見てきたように，ま
ず \texttt{uservec} と \texttt{usertrap} を実行し，その
あと \texttt{syscall} を呼びます．

\indexcode{syscall} 
\lineref{kernel/syscall.c:/^syscall/} 
は，トラップフレームから, か
つて \texttt{a7} レジスタに入っていたシステムコール番号を読み出し，シス
テムコールテーブルを表引きします．最初のシステムコールで
は，\texttt{a7} レジスタには \indexcode{SYS_exec} 
\lineref{kernel/syscall.h:/SYS_exec/} が
入っており，\texttt{syscall} はシステムコールテーブルにおけ
る \lstinline{SYS_exec} に対応するエントリである \lstinline{sys_exec} を呼び
出します．

\lstinline{syscall} は，システムコール関数からの返値
を\lstinline{p->tf->a0} に保存します．システムコールがユーザ空間にリターン
するとき，\lstinline{userret} は \indexcode{p->tf} に入っている値をマシンのレ
ジスタにロードした上で，\lstinline{sret} 命令によりユーザ空間へリターンし
ます．その中で，システムコールハンドラの返値が, \lstinline{a0} レジスタへ
入ります
\lineref{kernel/syscall.c:/a0 = syscalls/}．
システムコールからの返値は，エラー時は
負の数，正常時はゼロとするのが慣習です．システムコール番号が不正であった場合，
\lstinline{syscall} はエラーを表示するとともに，$-1$ を返します．


\section{Code: システムコールの引数}

あとの章では，特定のシステムコールの実装を見ます．この章は，システムコー
ルそのもののメカニズムに興味があります．まだ説明していないメカニズムが
1つあります．それは，システムコールの引数の見つけ方です．

RISC-V の C の呼び出し規約は，引数をレジスタで渡すことを決めています．
システムコールの途中で，これらのレジスタ（すなわち，退避されたユーザレ
ジスタ）は \texttt{p->tf} のトラップフレームでアクセスできま
す．\lstinline{argint}, \lstinline{argaddr}, および \lstinline{argfd} 関数
は，\textit{n} 番目のシステムコール引数を，それぞれ整数，ポインタ，およびファ
イルディスクリプタとして返します．それらはいずれも，\texttt{argraw} を呼び
出すことで，退避されたユーザレジスタを取得します
\lineref{kernel/syscall.c:/^argraw/}．

ポインタを引数として要求するシステムコールでは，カーネルはそれらのポイ
ンタを用いてメモリの読み書きをする必要があります．たとえ
ば，\texttt{exec} システムコールは，ポインタ配列を引数として渡します．
そのポインタは，ユーザ空間にある文字列引数を指しています．このようなポ
インタの取り扱いには2つの課題があります．第一に，バグっていたり，悪意を
持っているユーザプログラムが，不正なポインタを渡すことでカーネルをだま
し，ユーザメモリではなくカーネルメモリにアクセスをさせようとするかもし
れません．第二に，xv6 のカーネルページのマッピングは，ユーザーページテー
ブルとは異なりますので，カーネルがユーザが渡したアドレスに読み書きをす
るのに，通常の命令を使うことができません．

ユーザ空間からの読み込みを安全に行わなくてはいけないカーネル関数がたく
さんあります．\texttt{fetchstr} はその一例です
\lineref{kernel/syscall.c:/^fetchstr/}．\texttt{exec} のようなファイルのシステムコー
ルは，\texttt{fetchstr} を利用してユーザ空間から文字列引数を取得しま
す．\lstinline{fetchstr} が呼ぶ \lstinline{copyinstr} は，ユーザページテーブ
ルから仮想アドレスを探し，カーネルが使えるアドレスに変換し，そしてその
アドレスにある文字列をカーネルにコピーします．

\texttt{copyinstr} 
\lineref{kernel/vm.c:/^copyinstr/} は, ユーザページテーブ
ル \texttt{pagetable} にある仮想アドレス \texttt{srcva} から，最大
で \texttt{max} バイトを読み出し，\texttt{dst} にコピーします．その関数
は，\texttt{walkaddr} (内部的に \texttt{walk} を呼びます) を用いてソフ
トウェア的にページテーブルを参照し，仮想アドレス \texttt{srcva} に対応
する物理アドレス \texttt{pa0} を得ます．カーネルは物理 RAM 全体をそのカー
ネル仮想アドレスにマップしているの
で，\texttt{copyinstr} は \texttt{pa0} から \texttt{dst} へ，文字列を直
接コピーすることができます．\texttt{walkaddr} 
\lineref{kernel/vm.c:/^walkaddr/}
は，ユーザが指定した仮想アドレスが，そのプロセスのアドレス空間に含まれることを
確認することで，そのプログラムがカーネルをだまして別のメモリを読むこと
ができないようにします．似た関数 \texttt{copyout} は，カーネルから
ユーザが指定したアドレスに対してデータをコピーします．

\section{デバイスドライバ}

\indextext{ドライバ}とは，オペレーティングシステムに含まれるコードで，
特定のデバイスを管理するためのものです．ドライバはデバイスハードウェア
に処理をさせたり，それが終わったら割込をかけるように設定したり，結果と
して生じた割込を処理したり，また，そのデバイスの I/O を待っているプロセ
スとやりとりをしたりします．管理しているデバイスと並行して実行するので，
ドライバのコードはトリッキーになりがちです．また，ドライバは，複雑だっ
たりろくにドキュメント化されていなかったりする，デバイスのハードウェア
インタフェースを理解できなくてはなりません．

オペレーティングシステムからの注意を必要とするデバイスは，通常，トラッ
プの一種である割込を発生するように設定します．カーネルのトラップを処理
するコードは，デバイスがいつ割込を発生したのか認識し，そのドライバの割
込ハンドラを呼び出さなくてはいけません．xv6 では，このような
呼び出しは，\texttt{devintr} 
\lineref{kernel/trap.c:/^devintr/}
で行われます．

多くのデバイスドライバには，2つの重要な部分があります．プロセスの一部と
して動くコードと，割込時に動くコードです．プロセスレベルのコードは，デ
バイスに対して I/O を行う，\texttt{read} や \texttt{write} などのシステ
ムコールによって駆動されます．このコードは，ハードウェアに処理の開始を
指示することがあります（例: ディスクに対し，あるブロックの読み出しを要
求する）．そのあと，そのコードは処理の完了を待ちます．いずれ，そのデバ
イスを処理を完了し，割込を発生させます．そのドライバの割込ハンドラは，
（もしあるなら）どのオペレーションが完了したのか解明し，適切なものであ
れば待っていたプロセスを起床させます．場合によっては，順番待ちになって
いた次のしごとをハードウェアに開始させます．

\section{Code: コンソールドライバ}

コンソールドライバは，ドライバ構造を端的に示す例です．コンソールドライ
バは，RISC-V に付属の \indextext{UART} シリアルポートのハードウェアから，人間が打鍵
した文字列を受け取ります．ドライバは，1行ごとに入力を蓄積するとともに，
特殊な入力文字（バックスペースや Control-u）を処理します．シェ
ルなどのユーザプロセスは，\texttt{read} システムコールを用いることで，
コンソールからの入力を行単位で取得できます．QEMU において xv6 に対して
打鍵すると，あなたの打鍵は QEMU がシミュレートする UART ハードウェアに
よって xv6 へ届きます．

ドライバが相手にするのは QEMU がエミュレートする 16550 チッ
プです~\cite{ns16550a}．実際のコンピュータにおいて，16550
は，コンピュータもしくは端末に接続された RS232 シリアルリンクを管理しま
す．QEMU を実行しているとき，16550 はあなたのキーボードとディスプレイに
つながっています．

UART ハードウェアは，ソフトウェアにとって，メモリにマップされた制御レジ
スタに見えます．すなわち，ある物理アドレスが UART デバイスにつながって
おり，そのアドレスに読み書きをすると，（RAM ではなく）デバイスのハード
ウェアとやりとりできます．UART がマップされたアドレス
は\texttt{0x10000000} もしくは \texttt{UART0} です
\lineref{kernel/uart.c:/define.RHR/}．
UART の制御レジスタはい
くつもあり，いずれも 1 バイト長です．それらの，\texttt{UART0} からのオフ
セットは \lineref{kernel/uart.c:/define.RHR/} で定義されています．たとえば \texttt{LSR}
レジスタには，ソフトウェアが読み出すことができる入力文字列があるかどう
かを示すビット列が含まれます．それらの文字列（ある場合）
は，\texttt{RHR} レジスタから読むことができます．読むたびに，UART ハー
ドウェアは待機中の文字が入る内部の FIFO からそれを消去し，もし FIFO
が空になれば \texttt{LSR} レジスタの ``ready'' ビットをゼロにします．

xv6 の \texttt{main} は，\texttt{consoleinit} 
\lineref{kernel/console.c:/^consoleinit/} を
呼ぶことで UART ハードウェアを初期化するとともに，入力時に割込を生成するように
設定します \lineref{kernel/uart.c:/^uartinit/}.

xv6 のシェルは，\texttt{init.c}
\lineref{user/init.c:/open..console/} が開いたファイルディス
クリプタを介してコンソールから読み込みを行います．\texttt{read} シス
テムコールの呼び出すと，カーネルは\texttt{consoleread}
\lineref{kernel/console.c:/^consoleread/} を呼び出します．
\texttt{consoleread} は（割込によ
り）入力が来て\texttt{cons.buf} にバッファされるまで待ち，その入力をユー
ザ空間にコピーし，（行全体が届いたあとで）ユーザプロセスにリターンしま
す．ユーザが行全体をまだ入力し終えていないあいだ，あらゆる読み込み
プロセスは \texttt{sleep} を呼んで待ちます
\lineref{kernel/console.c:/sleep..cons/}．
\texttt{sleep} については，\ref{CH:SCHED}~章で説明をします．

ユーザが文字列を打鍵したら，UART ハードウェアは RISC-V に対して割込をす
るように要求します．RISC-V と xv6 はこれまで述べた方法で割込を
処理し，xv6 のトラップ処理コードが\texttt{devintr}
\lineref{kernel/trap.c:/^devintr/}
を呼びます．\texttt{devintr} は，RISC-V の \texttt{scause} レジスタを見
て，その割込が外部デバイスから来たものだと気づきます．その
あと，\texttt{devintr} は，PLIC と呼ばれるハードウェアユニッ
ト~\cite{riscv:priv} に問い合わせて，どのデバイスが割込をしたのか教えてもらいます
\lineref{kernel/trap.c:/plic.claim/}. 
もしそれが UART であった場
合，\texttt{devintr} は \texttt{uartintr} を呼び出します.


\texttt{uartintr}
\lineref{kernel/uart.c:/^uartintr/}
は，UART ハードウェアから届いた待
ち中の入力を全て読み出し，それを \texttt{consoleintr} に渡しま
す．\texttt{uartintr} は，次の文字列が来るのは待ちません．将来の入力
はまた別の割込を発生させるからです．\texttt{consoleintr} のしごとは，行
全体が届くまで，入力文字列を \texttt{cons.buf} に蓄積することで
す．\texttt{consoleintr} は，バックスペースなどの特殊文字列の処理を行い
ます．改行文字が届いたら，\texttt{consoleintr} は（もしあるなら）待って
いた\texttt{consoleread} を起床させます．

起床後，\texttt{consoleread} は，\texttt{cons.buf} に1行分のデータを見
つけ，それをユーザ空間にコピーし，（システムコールの機構を用いて）ユー
ザ空間へリターンします．

マルチコアのマシンにおいて，割込はどの CPU に届くこともありえます．どれ
にするかは，PLIC が管理しています．割込は，コンソールからの読
み込みを待っているプロセスを実行している CPU に届くかもしれませんし，まっ
たく関係ないことをやっている CPU に届くこともあります．
割込ハンドラは，割り込まれたプロセスやコードについて考える必要はありません．

\section{世の中のオペレーティングシステム}

カーネルのメモリが全プロセスのユーザページテーブルにマップしてあれば，
特別なトランポリンページは省略できます．その場合さらに，ユーザ空間から
カーネル空間へのとトラップ時に，ページテーブルを切り替える必要もなくな
ります．その逆に，カーネル内のシステムコール実装は，ユーザメモリがマッ
プされていることを利用して，ユーザポインタを直接デリファレンスできます．
多くのオペレーティングシステムが，効率化のために，このアイディアを採用
しています．xv6 がそうしないのは，ユーザから届いたポインタを不注意に扱
うことによるセキュリティに関わるバグの可能性を減らすためです．また，ユー
ザとカーネルの仮想アドレスが重なってしまわないように管理する手間を減ら
すという利点もあります．

xv6 は，カーネル実行時でも，ユーザプログラムの実行時と同じように，デバ
イス割込とタイマ割込を受け付けます．タイマ割込は，たとえカーネルが実行
中であっても，タイマ割込ハンドラにより，スレッドを強制的に切り替えます
（\texttt{yield} の呼び出し）．カーネルスレッドはたくさん計算をすること
がありますので，カーネルスレッドに対しても公平にタイムスライスを行う能
力は便利です．その一方，カーネルのコードが，タイマ割込によって中断され，
そのあとに再開するかもしれないことは，xv6 をい
くらか複雑にしています．デバイスおよびタイマ割込をユーザコードの実行中しか
受け付けないように限定すれば，カーネルをあるていど簡単にすることができます．

特定のコンピュータに搭載された全てのデバイスの全ての能力を引き出すこと
は大変です．デバイスはたくさんありますし，各デバイスにはたくさんの機能
があるからです．また，デバイスとドライバ間のプロトコルは，複雑であった
り，よくドキュメント化されていないこともあります．多くのオペレーティン
グシステムにおいて，ドライバは，カーネルのコアよりも多くのコードを占め
ます．

UART ドライバは，UART 制御レジスタを見ることで，データを1バイトずつ取得
します．これは，ソフトウェアがデータの移動を駆動しているので，
\indextext{プログラムド I/O} と呼ばれるパターンです．プログラムド I/O はシンプルですが，高
いデータレートで使うには遅すぎます．たくさんのデータを高スピードで動か
すデバイスは，通常，\indextext{ダイレクトメモリアクセス (DMA)} を使います．DMA デバ
イスハードウェアは，CPU に届くデータを直接 RAM に書き込んだり，CPU から
出ているデータをRAM から直接読んだりできます．現代的なディスクやネット
ワークデバイスは DMA を使います．DMA デバイスのドライバは，RAM にデータ
を用意し，一度だけ制御レジスタに書き込みを行い，そのデータの処理を指示
します．

デバイスが予測できないタイミングで，かつそこまで高くない頻度で CPU の注
意を必要とするとき，割込は理にかなった方法です．しかし割込には大き
なCPU オーバーヘッドがあります．よって，ネットワークやディスクのコント
ローラなどの高速なデバイスでは，割込を減らすテクニックが求められま
す．1つのテクニックは，読み出し・書き込みリクエストの大きな塊ごとに，1
回だけ割込を行うというものです．また別のテクニックは，割込を完全に止め
てしまい，そのデバイスが注意を求めていないか定期的にチェックするという
ものです．これは，\indextext{ポーリング}と呼ばれるテクニックです．ポーリングはデバ
イスの処理がすごく速いときに理にかなった方法ですが，そのデバイスが大部
分の時間を待機している場合は，CPU の浪費となります．現在のデバイスの負
荷に応じて，ポーリングと割込を動的に切り替えるドライバもあります．

UART ドライバは，届いたデータをユーザ空間にコピーする前に，まずカー
ネル内のバッファにコピーします．これは，データレートが低いときは理にかなっ
た方法です．しかし，高速でデータを生成・消費するデバイスでは，そのよう
な 2 重コピーが，劇的にパフォーマンスを低下させることがあります．オペレー
ティングシステムによっては，ユーザ空間にあるバッファとデバイスハードウェ
アが直接やりとりできます．これは多くの場合， DMA を用いて行います．

\section{練習問題}

\begin{enumerate}

\item \texttt{uartputc} \lineref{kernel/uart.c:/^uartputc/} は，UART デバイスが先の出力
  文字を処理し終わるまでポーリングして待ちます．割込を使うように書き換えてください．

\item Ethernet カードのドライバを追加してください．

\end{enumerate}
