\chapter{並行性・再び}
\label{CH:LOCK2}

良い並列性能，並列処理のおける正しさ，および理解しやすいコードの3つを満
たすことは，カーネル設計における大きな課題です．素直なロックの使用
はよい方法ですが，いつもできるわけではありません．この章で
は，xv6 がややこしい方法でロックを使わなくてはならなかった例と，
ロック的だがロックではない方法を使う例を紹介します．

\section{ロックのパターン}

キャッシュされたアイテムをロックするのは難しいことがあります．たとえば，
ファイルシステムのブロックキャッシュ
\lineref{kernel/bio.c:/^struct/} は，ディスクブロッ
クのコピーを \texttt{NBUF} 個まで持つことができます．あるディスクブロッ
クに対し，キャッシュ内のコピーが最大でも 1 個であることは非常に重要です．
そうしないと，同じブロックを示す異なるキャッシュが食い違うかもしれない
からです．キャッシュされたブロックは \texttt{buf} 構造
体 \lineref{kernel/buf.h:1} に入ります．\texttt{buf} 構造体にあるロック用のフィー
ルドが，あるブロックを一度にひとつのプロセスしか使えないことを保証しま
す．しかし，ロックだけでは足りません．ブロックがそもそもキャッシュに入っ
てなかったらどうなるでしょうか？（そのブロックはキャッシュされていない
ので）\texttt{buf} 構造体は存在せず，よってロックそのものが存在しませ
ん．xv6 はそのような状況を取り扱うために，キャッシュブロックの素性と追
加のロック (\texttt{bcache.lock}) を関連づけます．ブロックがキャッシュ
されているかどうかをチェックしなくてはならないコード（たとえ
ば \texttt{bget} \lineref{kernel/bio.c:/^bget/}）や，複数のキャッシュブロッ
クを書き換えるコードは \texttt{bcache.lock} を取得しなくてはなりません．
必要なブロックや \texttt{buf} 構造体を見つけたら，そのコード
は \texttt{bcache.lock} を解放し，それからブロック固有のロックを取
得します．アイテムの集合に対するロック 1 つと，各アイテムご
とにロックの組み合わせは頻出のパターンです．

通常，ロックを取得した関数がその解放も行います．しかし，より正確な理解
は，アトミックに見えなくてはならないシーケンスの始まりでロックを取得し，
そのシーケンスの終わりにロックを解放する，というものです．もしシーケン
スの始まりと終わりが別の関数，別のスレッド，もしくは別の CPU にあるなら
ば，ロックの取得・解放もそうしなくてはなりません．ロックの機能は他の利
用者を待たせることであって，あるデータを特定のエージェントに紐付けする
ことではありません．1 つの例は \texttt{yield} \lineref{kernel/proc.c:/^yield/} にお
ける \texttt{acquire} で，\texttt{acquire} を呼んだプロセスでは
なく，スケジューラスレッドで解放されます．さらに別の例
は \texttt{ilock} \lineref{kernel/fs.c:/^ilock/} における\texttt{acquiresleep} で
す．このコードはディスクを読みながらスリープすることがよくあり，すると
別の CPU で起床します．すなわち，ロックの解放が別の CPU で行われます．

オブジェクトには，そのオブジェクト自身に埋め込んであるロックによって保
護されているものがあり，そのようなオブジェクトを解放（消去) するのは
デリケートな仕事です．正しく解放するには，ロックだけでは足りない
からです．問題が起きるのは，別のスレッドがそのオブジェクトを使用するた
めに \texttt{acquire} で待っていた場合です．オブジェクトの解放は，ロッ
クの解放を意味するので，待っていたスレッドが誤動作してしまいます．解決
法の1つは，そのオブジェクトへの参照を数えておき，最後の参照が消滅した時
点でのみ解放を行うというものです．\texttt{pipeclose} \lineref{kernel/pipe.c:/^pipeclose/} が
その例です．\texttt{pi->readopen} と \texttt{pi->writeopen} が，そのパイプを参
照するファイルディスクリプタが存在するかどうかを追跡しています．

% sleep locks.
% hand-over-hand locking in namei.
%   namei's use of refcount to prevent changing underfoot,
%     and lock when actually using it.
% example of where deadlock is avoided? namei?
% spawn a thread to evade a lock order problem?

\section{ロック的なパターン}

多くの場面で，xv6 は参照カウントまたはフラグをソフトロック的なものとし
て利用することで，そのオブジェクトがアロケート済みで，解放したり再利用
してはならないことを表します．プロセスの \texttt{p->state} は，ファイル,
\texttt{inode}, および \texttt{buf} 構造体の参照カウントと同様に動きま
す．いずれの場合でも，ロックが存在してフラグ・参照カウントを保護しますが，
オブジェクトの予期せぬ解放を防ぐのは後者です．

ファイルシステムは \texttt{inode} 構造体の参照カウントを複数プロセスが
共有するロックのようなものとして使うことで，通常のロックならば生じてし
まうデッドロックを回避します．たとえば，\texttt{namex}
\lineref{kernel/fs.c:/^namex/} のループは，パス名に含まれる各部位に対応する名前のディ
レクトリをロックします．しかし \texttt{namex} は，各ループの最後でそれ
ぞれのロックを解放しなくてはなりません．複数のロックを持つと，ドットを
含むパス名（たとえば \texttt{a/./b}）のときに自身とデッドロックするから
です．そのディレクトリと \texttt{..} に並行アクセスするこ
とによるデッドロックの可能性もあります．この問題は，\ref{CH:FS}~章で説明したように，
ロックはせずに，しかし参照カウントは増やしたままで\texttt{inode} 構造体
を次のループに持ち越すことで解決できます．

その時々で異なるメカニズムで保護され，場合によっては明示的なロックでは
なく，xv6 のコード構造による暗黙的な並行アクセスによって保護されるデー
タもあります．たとえば，ある物理ページが使用可能なとき，それ
は\texttt{kmem.lock} \lineref{kernel/kalloc.c:/^. kmem;/} によって保護されます．もしそ
のページがそのあとパイプとしてアロケートされたら \lineref{kernel/pipe.c:/^pipealloc/}, 今度
は別のロック (埋め込まれた \texttt{pi->lock}) で保護されます．また，そ
のページが新しいプロセスのユーザメモリとしてさらに再アロケートされたら，
ロックによる保護は無くなります．そのかわり，「アロケータはそのページを
（解放されるまで）別のプロセスに渡さない」という事実が，そのページを並
行アクセスから保護します．新しいプロセスのメモリの所有権は複雑です．ま
ず，\texttt{fork} では親プロセスがアロケートと操作を行い，そのあとで子プ
ロセスが利用します．いずれ子プロセスが終了したら，親プロセスが再びその
メモリを所有して \texttt{kfree} に渡します．このことから学ぶべきこと
が 2 つあります．第一に，ライフタイムのときどきにおいて，
異なる方法で並行処理から保護されるデータオブジェクトがある．第二
に，明示的なロックではなく，その暗黙的な構造によって保護がなされ
ることがある．

最後のロック的なものの例は，\texttt{mycpu()} \lineref{kernel/proc.c:/^myproc/} 呼び出
しの周辺で割込を無効化することです．割込を無効化すると，
呼び出し元のコードは，コンテキストスイッチを引き起こすタイマ割込に対し
てアトミックになります．そうすることで，プロセスを別 CPU に移すことができる
ようになります．

\section{ロックしない}

xv6 は，まったくロックを使わずに，書き換え可能なデータを共有する
箇所も少しあります．一例はスピンロックの実装ですが，RISC-V のアトミック
命令を，ハードウェア実装されたロックだと解釈することもできま
す．別の例
は \texttt{main.c} の \texttt{started} 変数 
\lineref{kernel/main.c:/^volatile/} で，0 番
CPU が xv6 の初期を終えるまで，他の CPU が走るのを防ぐためのものです．
ここでは，\texttt{volatile} を使用することで，コンパイラがたしかにロード
命令とストア命令を生成することを保証しています．最後の例
は\texttt{proc.c} において \texttt{p->parent} を利用する箇所のいくつか
です \lineref{kernel/proc.c:/^wait/}
\lineref{kernel/proc.c:/^reparent/}．そこで正しくロックを行うと
デッドロックを引き起こす可能性があり，かつ他のプロセスが同時
に \texttt{p->parent} を書き換えることができないのはほとんど明らかです．
第四の例は \indexcode{p->killed} で，\texttt{p->lock} を保持する間にセット
されますが \lineref{kernel/proc.c:/^kill/}，ロックを取得することなくチェックされま
す \lineref{kernel/trap.c:/p->killed/}．

ある 1 つの CPU またはスレッドがデータを書き，また別の CPU またはスレッ
ドが読むが，そのデータのための専用のロックが無いという箇所が xv6 にはあ
ります．一例は \texttt{fork} で，親プロセスが子プロセスのユーザメモリペー
ジに書き込みを行い，子プロセス（別のスレッド，場合によっては別の CPU）
がそれを読みますが，それらのページを明示的に保護するロックはありません．
親プロセスが書き終えるまで子プロセスは実行を開始しませんので，厳密に言
えば，これはロックが必要な箇所ではありません．しかし，メモリバリアが無い限り，
ある CPU による書き込みが別 CPU に伝わる保証はないので，
潜在的なメモリの順序問題（\ref{CH:LOCK}~章を見てください）があります．しかし，親プロ
セスがロックを解放するとともに，子プロセスは開始時にロックを取得するの
で，\texttt{acquire} と \texttt{release} にあるメモリバリアが，親プ
ロセスが書いた内容を子プロセスが見れることを保証します．

\section{並列性}

ロックとは，突き詰めれば，正しさのために並列性を抑制することです．パ
フォーマンスもまた重要なので，カーネル設計者は，正しさと並列性を両立す
るためのロックの使い方についてよく考えます．xv6 は性能のためにシステマ
ティックに設計されたわけではありませんが，xv6 のオペレーションのうち並
列処理できるものと，ロックで競合するものについて考えることには価値があります．

xv6 のパイプは，極めてよい並列性を持つものの例です．各パイプには固有の
ロックがあるので，異なるプロセスは（異なる CPU で），異なるパイプを並列
で読み書きできます．ただし，同じパイプを読み書きするプロセス同士は，ロッ
クの解放をお互いに待たなくてはなりません．すなわち，同一のパイプに対す
る同時読み書きはできません．空のパイプからの読み出し（または満杯のパイ
プへの書き込み）についても同様ですが，これはロックに関連することではあ
りません．

コンテキストスイッチはさらに複雑な例です．それぞれ別の CPU で実行してい
る2つのカーネルスレッドは，\texttt{yield}, \texttt{sched}, およ
び\texttt{swtch} を同時に呼び，並列で実行することがありえます．
どちらのスレッドもロックを取得しますが，それらは別のロックなので，
お互いを待つことをしません．ただしスケジューラ内では，テーブルか
ら \texttt{RUNNABLE} なプロセスを探すループにおいて，2つの CPU はコンフ
リクトするかもしれません．すなわち，xv6 は，コンテキストスイッチ時
に CPU が複数あることのご利益をうけることができますが，おそらく改善の余地
があります．

別の例は，別の CPU で実行する別のプロセスが，並行して\texttt{fork} を呼
び出した場合です．それらは，\texttt{pid\_lock}, \texttt{kmem.lock}, お
よびプロセステーブルから \texttt{UNUSED} プロセスを探すためのプロセス固
有のロックのためにお互いを待つ可能性があります．一
方，2つの \texttt{fork} は，ユーザページのコピーとページテーブル用ペー
ジの初期化を完全に並列で処理できます．

上記の例で示したロック方式は，並列性を犠牲にする場合があります．いずれ
のケースでも，より練られた設計をすることで，並列度を改善することができ
ます．やる価値があるかどうかは，その詳細によります．すなわち，そ
のオペレーションが呼ばれる頻度，コードがロックの取り合いに費やす時間，
それらのコードに別のボトルネックは無いか，などです．あるロック方式がパ
フォーマンスの問題を生じているかどうか，また新しい方式により大きな改善
を得られるかどうかを推定するのは難しいことがあります．よって，現実的な
負荷での計測が必要になることがしばしばあります．

\section{練習問題}

\begin{enumerate}

\item xv6 のパイプ実装を改造して，異なるコアから同一パイプへの読み込
  みと書き出しが，同時に実行できるようにしてください．

\item xv6 の \texttt{scheduler()} を改造して，異なるコアが同時に実行可
  能プロセスを探すときに生じるロックの取り合いを減らしてください．

\item xv6 の \texttt{fork()} におけるシリアル化をいくつか減らしてください．

\end{enumerate}

% is p->killed another example of cutting locking corners?
